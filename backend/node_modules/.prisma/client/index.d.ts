
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: number
  username: string
  password: string
  deleted: boolean
}

/**
 * Model Roles
 */

export type Roles = {
  id: number
  userId: number
  role: Role
}

/**
 * Model Guru
 */

export type Guru = {
  id: number
  nig: string
  nigs: string
  kodeGuru: string
  nama: string
  email: string
  jenisKelamin: JenisKelamin
  tempatLahir: string
  tanggalLahir: Date
  tanggalMasuk: Date
  profileUrl: string | null
  deleted: boolean
}

/**
 * Model GuruDetails
 */

export type GuruDetails = {
  guruId: number
  userId: number
}

/**
 * Model GuruTahfidzDetails
 */

export type GuruTahfidzDetails = {
  guruId: number
  deleted: boolean
}

/**
 * Model Murid
 */

export type Murid = {
  id: number
  nis: string
  nism: string
  nisn: string | null
  nama: string
  jenisKelamin: JenisKelamin
  tempatLahir: string
  tanggalLahir: Date
  anakKe: number
  jumlahSaudaraKandung: number
  jumlahSaudaraTiri: number
  jumlahSaudaraAngkat: number
  golonganDarah: GolonganDarah | null
  profileUrl: string | null
  deleted: boolean
}

/**
 * Model MuridDetails
 */

export type MuridDetails = {
  muridId: number
  userId: number
}

/**
 * Model MuridTahfidzDetails
 */

export type MuridTahfidzDetails = {
  muridId: number
  kelompokTahfidzId: number
}

/**
 * Model Parent
 */

export type Parent = {
  id: number
  nip: string
  nama: string
  tempatLahir: string
  tanggalLahir: Date
  jenisKelamin: JenisKelamin
  agama: Agama
  pendidikanTerakhir: Pendidikan
  penghasilanPerBulan: number
  pekerjaan: string
  nomorTelepon: string
  statusHidup: Hidup
  profileUrl: string | null
  deleted: boolean
}

/**
 * Model ParentDetails
 */

export type ParentDetails = {
  parentId: number
  userId: number
}

/**
 * Model Event
 */

export type Event = {
  id: number
  type: TipeEvent
  target: EventModelType
  targetId: number
  userId: number
  time: Date
}

/**
 * Model Halaqoh
 */

export type Halaqoh = {
  id: number
  kode: string
  guruId: number
}

/**
 * Model Session
 */

export type Session = {
  id: number
  type: TipeSesi
  waktu: Date
  juz: number
  halaman: number
  awalSetoran: string
  akhirSetoran: string
  nilaiTajwid: number
  nilaiKelancaran: number
  nilaiMakhroj: number
  nilaiSifatHuruf: number
  jamTahfidz: string
  muridId: number
}

/**
 * Model JamTahfidz
 */

export type JamTahfidz = {
  id: number
  waktuMulai: Date
  waktuSelesai: Date
  namaJam: string
  tipe: TipeSesi
}

/**
 * Model AlQuran
 */

export type AlQuran = {
  id: number
  ayat: number
  baris: number
  halaman: number
  surah: number
  juz: number
  deleted: boolean
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Role: {
  ADMIN: 'ADMIN',
  GURU_TAHFIDZ: 'GURU_TAHFIDZ',
  GURU: 'GURU',
  MURID: 'MURID',
  KEPALA_TAHFIDZ: 'KEPALA_TAHFIDZ',
  PARENT: 'PARENT',
  TU: 'TU',
  INPUT_QURAN: 'INPUT_QURAN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const JenisKelamin: {
  M: 'M',
  F: 'F'
};

export type JenisKelamin = (typeof JenisKelamin)[keyof typeof JenisKelamin]


export const GolonganDarah: {
  A: 'A',
  B: 'B',
  O: 'O',
  AB: 'AB'
};

export type GolonganDarah = (typeof GolonganDarah)[keyof typeof GolonganDarah]


export const Agama: {
  Islam: 'Islam',
  Kristen: 'Kristen',
  Buddha: 'Buddha',
  Hindu: 'Hindu',
  Kong_Hu_Chu: 'Kong_Hu_Chu',
  Katolik: 'Katolik'
};

export type Agama = (typeof Agama)[keyof typeof Agama]


export const Pendidikan: {
  Tidak_Sekolah: 'Tidak_Sekolah',
  SD: 'SD',
  SMP: 'SMP',
  SMA: 'SMA',
  Diploma: 'Diploma',
  S1: 'S1',
  S2: 'S2',
  S3: 'S3'
};

export type Pendidikan = (typeof Pendidikan)[keyof typeof Pendidikan]


export const Hidup: {
  HIDUP: 'HIDUP',
  MENINGGAL: 'MENINGGAL'
};

export type Hidup = (typeof Hidup)[keyof typeof Hidup]


export const TipeEvent: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RECOVERY: 'RECOVERY'
};

export type TipeEvent = (typeof TipeEvent)[keyof typeof TipeEvent]


export const EventModelType: {
  USER: 'USER',
  GURU: 'GURU',
  HALAQOH: 'HALAQOH',
  MURID: 'MURID',
  PARENT: 'PARENT',
  SESSION: 'SESSION',
  ALQURAN: 'ALQURAN',
  JAM_TAHFIDZ: 'JAM_TAHFIDZ',
  ROLES: 'ROLES'
};

export type EventModelType = (typeof EventModelType)[keyof typeof EventModelType]


export const TipeSesi: {
  Murojah: 'Murojah',
  Hafalan: 'Hafalan'
};

export type TipeSesi = (typeof TipeSesi)[keyof typeof TipeSesi]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;


      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<GlobalReject>;

  /**
   * `prisma.guru`: Exposes CRUD operations for the **Guru** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gurus
    * const gurus = await prisma.guru.findMany()
    * ```
    */
  get guru(): Prisma.GuruDelegate<GlobalReject>;

  /**
   * `prisma.guruDetails`: Exposes CRUD operations for the **GuruDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuruDetails
    * const guruDetails = await prisma.guruDetails.findMany()
    * ```
    */
  get guruDetails(): Prisma.GuruDetailsDelegate<GlobalReject>;

  /**
   * `prisma.guruTahfidzDetails`: Exposes CRUD operations for the **GuruTahfidzDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuruTahfidzDetails
    * const guruTahfidzDetails = await prisma.guruTahfidzDetails.findMany()
    * ```
    */
  get guruTahfidzDetails(): Prisma.GuruTahfidzDetailsDelegate<GlobalReject>;

  /**
   * `prisma.murid`: Exposes CRUD operations for the **Murid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Murids
    * const murids = await prisma.murid.findMany()
    * ```
    */
  get murid(): Prisma.MuridDelegate<GlobalReject>;

  /**
   * `prisma.muridDetails`: Exposes CRUD operations for the **MuridDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuridDetails
    * const muridDetails = await prisma.muridDetails.findMany()
    * ```
    */
  get muridDetails(): Prisma.MuridDetailsDelegate<GlobalReject>;

  /**
   * `prisma.muridTahfidzDetails`: Exposes CRUD operations for the **MuridTahfidzDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MuridTahfidzDetails
    * const muridTahfidzDetails = await prisma.muridTahfidzDetails.findMany()
    * ```
    */
  get muridTahfidzDetails(): Prisma.MuridTahfidzDetailsDelegate<GlobalReject>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<GlobalReject>;

  /**
   * `prisma.parentDetails`: Exposes CRUD operations for the **ParentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParentDetails
    * const parentDetails = await prisma.parentDetails.findMany()
    * ```
    */
  get parentDetails(): Prisma.ParentDetailsDelegate<GlobalReject>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<GlobalReject>;

  /**
   * `prisma.halaqoh`: Exposes CRUD operations for the **Halaqoh** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Halaqohs
    * const halaqohs = await prisma.halaqoh.findMany()
    * ```
    */
  get halaqoh(): Prisma.HalaqohDelegate<GlobalReject>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<GlobalReject>;

  /**
   * `prisma.jamTahfidz`: Exposes CRUD operations for the **JamTahfidz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JamTahfidzs
    * const jamTahfidzs = await prisma.jamTahfidz.findMany()
    * ```
    */
  get jamTahfidz(): Prisma.JamTahfidzDelegate<GlobalReject>;

  /**
   * `prisma.alQuran`: Exposes CRUD operations for the **AlQuran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlQurans
    * const alQurans = await prisma.alQuran.findMany()
    * ```
    */
  get alQuran(): Prisma.AlQuranDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.3.0
   * Query Engine version: 33838b0f78f1fe9052cf9a00e9761c9dc097a63c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Roles: 'Roles',
    Guru: 'Guru',
    GuruDetails: 'GuruDetails',
    GuruTahfidzDetails: 'GuruTahfidzDetails',
    Murid: 'Murid',
    MuridDetails: 'MuridDetails',
    MuridTahfidzDetails: 'MuridTahfidzDetails',
    Parent: 'Parent',
    ParentDetails: 'ParentDetails',
    Event: 'Event',
    Halaqoh: 'Halaqoh',
    Session: 'Session',
    JamTahfidz: 'JamTahfidz',
    AlQuran: 'AlQuran'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    roles: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect = {
    roles?: boolean
    auditLogs?: boolean
  }

  export type UserCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UserCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UserCountOutputType
    : S extends undefined
    ? never
    : S extends UserCountOutputTypeArgs
    ?'include' extends U
    ? UserCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof UserCountOutputType ?UserCountOutputType [P]
  : 
     never
  } 
    : UserCountOutputType
  : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type GuruTahfidzDetailsCountOutputType
   */


  export type GuruTahfidzDetailsCountOutputType = {
    kelompokTahfidz: number
  }

  export type GuruTahfidzDetailsCountOutputTypeSelect = {
    kelompokTahfidz?: boolean
  }

  export type GuruTahfidzDetailsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | GuruTahfidzDetailsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? GuruTahfidzDetailsCountOutputType
    : S extends undefined
    ? never
    : S extends GuruTahfidzDetailsCountOutputTypeArgs
    ?'include' extends U
    ? GuruTahfidzDetailsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GuruTahfidzDetailsCountOutputType ?GuruTahfidzDetailsCountOutputType [P]
  : 
     never
  } 
    : GuruTahfidzDetailsCountOutputType
  : GuruTahfidzDetailsCountOutputType




  // Custom InputTypes

  /**
   * GuruTahfidzDetailsCountOutputType without action
   */
  export type GuruTahfidzDetailsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetailsCountOutputType
     * 
    **/
    select?: GuruTahfidzDetailsCountOutputTypeSelect | null
  }



  /**
   * Count Type MuridCountOutputType
   */


  export type MuridCountOutputType = {
    orangTua: number
  }

  export type MuridCountOutputTypeSelect = {
    orangTua?: boolean
  }

  export type MuridCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MuridCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MuridCountOutputType
    : S extends undefined
    ? never
    : S extends MuridCountOutputTypeArgs
    ?'include' extends U
    ? MuridCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MuridCountOutputType ?MuridCountOutputType [P]
  : 
     never
  } 
    : MuridCountOutputType
  : MuridCountOutputType




  // Custom InputTypes

  /**
   * MuridCountOutputType without action
   */
  export type MuridCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MuridCountOutputType
     * 
    **/
    select?: MuridCountOutputTypeSelect | null
  }



  /**
   * Count Type MuridTahfidzDetailsCountOutputType
   */


  export type MuridTahfidzDetailsCountOutputType = {
    sesi: number
  }

  export type MuridTahfidzDetailsCountOutputTypeSelect = {
    sesi?: boolean
  }

  export type MuridTahfidzDetailsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MuridTahfidzDetailsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MuridTahfidzDetailsCountOutputType
    : S extends undefined
    ? never
    : S extends MuridTahfidzDetailsCountOutputTypeArgs
    ?'include' extends U
    ? MuridTahfidzDetailsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MuridTahfidzDetailsCountOutputType ?MuridTahfidzDetailsCountOutputType [P]
  : 
     never
  } 
    : MuridTahfidzDetailsCountOutputType
  : MuridTahfidzDetailsCountOutputType




  // Custom InputTypes

  /**
   * MuridTahfidzDetailsCountOutputType without action
   */
  export type MuridTahfidzDetailsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetailsCountOutputType
     * 
    **/
    select?: MuridTahfidzDetailsCountOutputTypeSelect | null
  }



  /**
   * Count Type ParentCountOutputType
   */


  export type ParentCountOutputType = {
    daftarAnak: number
  }

  export type ParentCountOutputTypeSelect = {
    daftarAnak?: boolean
  }

  export type ParentCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ParentCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ParentCountOutputType
    : S extends undefined
    ? never
    : S extends ParentCountOutputTypeArgs
    ?'include' extends U
    ? ParentCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ParentCountOutputType ?ParentCountOutputType [P]
  : 
     never
  } 
    : ParentCountOutputType
  : ParentCountOutputType




  // Custom InputTypes

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     * 
    **/
    select?: ParentCountOutputTypeSelect | null
  }



  /**
   * Count Type HalaqohCountOutputType
   */


  export type HalaqohCountOutputType = {
    muridTahfidzDetail: number
  }

  export type HalaqohCountOutputTypeSelect = {
    muridTahfidzDetail?: boolean
  }

  export type HalaqohCountOutputTypeGetPayload<
    S extends boolean | null | undefined | HalaqohCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? HalaqohCountOutputType
    : S extends undefined
    ? never
    : S extends HalaqohCountOutputTypeArgs
    ?'include' extends U
    ? HalaqohCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof HalaqohCountOutputType ?HalaqohCountOutputType [P]
  : 
     never
  } 
    : HalaqohCountOutputType
  : HalaqohCountOutputType




  // Custom InputTypes

  /**
   * HalaqohCountOutputType without action
   */
  export type HalaqohCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the HalaqohCountOutputType
     * 
    **/
    select?: HalaqohCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    deleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    deleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    deleted: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    deleted?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    deleted?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    deleted?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }


    
    
  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    username: string
    password: string
    deleted: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Promise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], UserGroupByOutputType[P]> 
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      > 
    >


  export type UserSelect = {
    id?: boolean
    username?: boolean
    password?: boolean
    isGuru?: boolean | GuruDetailsArgs
    isMurid?: boolean | MuridDetailsArgs
    isParent?: boolean | ParentDetailsArgs
    deleted?: boolean
    roles?: boolean | RolesFindManyArgs
    auditLogs?: boolean | EventFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserInclude = {
    isGuru?: boolean | GuruDetailsArgs
    isMurid?: boolean | MuridDetailsArgs
    isParent?: boolean | ParentDetailsArgs
    roles?: boolean | RolesFindManyArgs
    auditLogs?: boolean | EventFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'isGuru'
        ? GuruDetailsGetPayload<S['include'][P]> | null :
        P extends 'isMurid'
        ? MuridDetailsGetPayload<S['include'][P]> | null :
        P extends 'isParent'
        ? ParentDetailsGetPayload<S['include'][P]> | null :
        P extends 'roles'
        ? Array < RolesGetPayload<S['include'][P]>>  :
        P extends 'auditLogs'
        ? Array < EventGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'isGuru'
        ? GuruDetailsGetPayload<S['select'][P]> | null :
        P extends 'isMurid'
        ? MuridDetailsGetPayload<S['select'][P]> | null :
        P extends 'isParent'
        ? ParentDetailsGetPayload<S['select'][P]> | null :
        P extends 'roles'
        ? Array < RolesGetPayload<S['select'][P]>>  :
        P extends 'auditLogs'
        ? Array < EventGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? UserCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    isGuru<T extends GuruDetailsArgs = {}>(args?: Subset<T, GuruDetailsArgs>): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails | null >, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T> | null >>;

    isMurid<T extends MuridDetailsArgs = {}>(args?: Subset<T, MuridDetailsArgs>): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails | null >, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T> | null >>;

    isParent<T extends ParentDetailsArgs = {}>(args?: Subset<T, ParentDetailsArgs>): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails | null >, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T> | null >>;

    roles<T extends RolesFindManyArgs = {}>(args?: Subset<T, RolesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Roles>>, PrismaPromise<Array<RolesGetPayload<T>>>>;

    auditLogs<T extends EventFindManyArgs = {}>(args?: Subset<T, EventFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Roles
   */


  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    userId: number | null
    role: Role | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    role: Role | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    _all?: true
  }

  export type RolesAggregateArgs = {
    /**
     * Filter which Roles to aggregate.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }


    
    
  export type RolesGroupByArgs = {
    where?: RolesWhereInput
    orderBy?: Enumerable<RolesOrderByWithAggregationInput>
    by: Array<RolesScalarFieldEnum>
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }


  export type RolesGroupByOutputType = {
    id: number
    userId: number
    role: Role
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Promise<
    Array<
      PickArray<RolesGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], RolesGroupByOutputType[P]> 
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      > 
    >


  export type RolesSelect = {
    id?: boolean
    userId?: boolean
    user?: boolean | UserArgs
    role?: boolean
  }

  export type RolesInclude = {
    user?: boolean | UserArgs
  }

  export type RolesGetPayload<
    S extends boolean | null | undefined | RolesArgs,
    U = keyof S
      > = S extends true
        ? Roles
    : S extends undefined
    ? never
    : S extends RolesArgs | RolesFindManyArgs
    ?'include' extends U
    ? Roles  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Roles ?Roles [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Roles
  : Roles


  type RolesCountArgs = Merge<
    Omit<RolesFindManyArgs, 'select' | 'include'> & {
      select?: RolesCountAggregateInputType | true
    }
  >

  export interface RolesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RolesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Roles'> extends True ? CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>> : CheckSelect<T, Prisma__RolesClient<Roles | null >, Prisma__RolesClient<RolesGetPayload<T> | null >>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RolesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Roles'> extends True ? CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>> : CheckSelect<T, Prisma__RolesClient<Roles | null >, Prisma__RolesClient<RolesGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolesFindManyArgs>(
      args?: SelectSubset<T, RolesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Roles>>, PrismaPromise<Array<RolesGetPayload<T>>>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
    **/
    create<T extends RolesCreateArgs>(
      args: SelectSubset<T, RolesCreateArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Create many Roles.
     *     @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const roles = await prisma.roles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolesCreateManyArgs>(
      args?: SelectSubset<T, RolesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
    **/
    delete<T extends RolesDeleteArgs>(
      args: SelectSubset<T, RolesDeleteArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolesUpdateArgs>(
      args: SelectSubset<T, RolesUpdateArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolesDeleteManyArgs>(
      args?: SelectSubset<T, RolesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolesUpdateManyArgs>(
      args: SelectSubset<T, RolesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
    **/
    upsert<T extends RolesUpsertArgs>(
      args: SelectSubset<T, RolesUpsertArgs>
    ): CheckSelect<T, Prisma__RolesClient<Roles>, Prisma__RolesClient<RolesGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RolesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Throw an Error if a Roles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Throw an Error if a Roles can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     * 
    **/
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles findMany
   */
  export type RolesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Filter, which Roles to fetch.
     * 
    **/
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     * 
    **/
    orderBy?: Enumerable<RolesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     * 
    **/
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<RolesScalarFieldEnum>
  }


  /**
   * Roles create
   */
  export type RolesCreateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The data needed to create a Roles.
     * 
    **/
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }


  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs = {
    data: Enumerable<RolesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Roles update
   */
  export type RolesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The data needed to update a Roles.
     * 
    **/
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs = {
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    where?: RolesWhereInput
  }


  /**
   * Roles upsert
   */
  export type RolesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * The filter to search for the Roles to update in case it exists.
     * 
    **/
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     * 
    **/
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }


  /**
   * Roles delete
   */
  export type RolesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
    /**
     * Filter which Roles to delete.
     * 
    **/
    where: RolesWhereUniqueInput
  }


  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs = {
    where?: RolesWhereInput
  }


  /**
   * Roles without action
   */
  export type RolesArgs = {
    /**
     * Select specific fields to fetch from the Roles
     * 
    **/
    select?: RolesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: RolesInclude | null
  }



  /**
   * Model Guru
   */


  export type AggregateGuru = {
    _count: GuruCountAggregateOutputType | null
    _avg: GuruAvgAggregateOutputType | null
    _sum: GuruSumAggregateOutputType | null
    _min: GuruMinAggregateOutputType | null
    _max: GuruMaxAggregateOutputType | null
  }

  export type GuruAvgAggregateOutputType = {
    id: number | null
  }

  export type GuruSumAggregateOutputType = {
    id: number | null
  }

  export type GuruMinAggregateOutputType = {
    id: number | null
    nig: string | null
    nigs: string | null
    kodeGuru: string | null
    nama: string | null
    email: string | null
    jenisKelamin: JenisKelamin | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    tanggalMasuk: Date | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type GuruMaxAggregateOutputType = {
    id: number | null
    nig: string | null
    nigs: string | null
    kodeGuru: string | null
    nama: string | null
    email: string | null
    jenisKelamin: JenisKelamin | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    tanggalMasuk: Date | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type GuruCountAggregateOutputType = {
    id: number
    nig: number
    nigs: number
    kodeGuru: number
    nama: number
    email: number
    jenisKelamin: number
    tempatLahir: number
    tanggalLahir: number
    tanggalMasuk: number
    profileUrl: number
    deleted: number
    _all: number
  }


  export type GuruAvgAggregateInputType = {
    id?: true
  }

  export type GuruSumAggregateInputType = {
    id?: true
  }

  export type GuruMinAggregateInputType = {
    id?: true
    nig?: true
    nigs?: true
    kodeGuru?: true
    nama?: true
    email?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    tanggalMasuk?: true
    profileUrl?: true
    deleted?: true
  }

  export type GuruMaxAggregateInputType = {
    id?: true
    nig?: true
    nigs?: true
    kodeGuru?: true
    nama?: true
    email?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    tanggalMasuk?: true
    profileUrl?: true
    deleted?: true
  }

  export type GuruCountAggregateInputType = {
    id?: true
    nig?: true
    nigs?: true
    kodeGuru?: true
    nama?: true
    email?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    tanggalMasuk?: true
    profileUrl?: true
    deleted?: true
    _all?: true
  }

  export type GuruAggregateArgs = {
    /**
     * Filter which Guru to aggregate.
     * 
    **/
    where?: GuruWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gurus to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuruWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gurus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gurus.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gurus
    **/
    _count?: true | GuruCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuruAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuruSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuruMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuruMaxAggregateInputType
  }

  export type GetGuruAggregateType<T extends GuruAggregateArgs> = {
        [P in keyof T & keyof AggregateGuru]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuru[P]>
      : GetScalarType<T[P], AggregateGuru[P]>
  }


    
    
  export type GuruGroupByArgs = {
    where?: GuruWhereInput
    orderBy?: Enumerable<GuruOrderByWithAggregationInput>
    by: Array<GuruScalarFieldEnum>
    having?: GuruScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuruCountAggregateInputType | true
    _avg?: GuruAvgAggregateInputType
    _sum?: GuruSumAggregateInputType
    _min?: GuruMinAggregateInputType
    _max?: GuruMaxAggregateInputType
  }


  export type GuruGroupByOutputType = {
    id: number
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date
    tanggalMasuk: Date
    profileUrl: string | null
    deleted: boolean
    _count: GuruCountAggregateOutputType | null
    _avg: GuruAvgAggregateOutputType | null
    _sum: GuruSumAggregateOutputType | null
    _min: GuruMinAggregateOutputType | null
    _max: GuruMaxAggregateOutputType | null
  }

  type GetGuruGroupByPayload<T extends GuruGroupByArgs> = Promise<
    Array<
      PickArray<GuruGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GuruGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GuruGroupByOutputType[P]> 
            : GetScalarType<T[P], GuruGroupByOutputType[P]>
        }
      > 
    >


  export type GuruSelect = {
    id?: boolean
    nig?: boolean
    nigs?: boolean
    kodeGuru?: boolean
    nama?: boolean
    email?: boolean
    jenisKelamin?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    tanggalMasuk?: boolean
    profileUrl?: boolean
    deleted?: boolean
    guruDetails?: boolean | GuruDetailsArgs
  }

  export type GuruInclude = {
    guruDetails?: boolean | GuruDetailsArgs
  }

  export type GuruGetPayload<
    S extends boolean | null | undefined | GuruArgs,
    U = keyof S
      > = S extends true
        ? Guru
    : S extends undefined
    ? never
    : S extends GuruArgs | GuruFindManyArgs
    ?'include' extends U
    ? Guru  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guruDetails'
        ? GuruDetailsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Guru ?Guru [P]
  : 
          P extends 'guruDetails'
        ? GuruDetailsGetPayload<S['select'][P]> | null : never
  } 
    : Guru
  : Guru


  type GuruCountArgs = Merge<
    Omit<GuruFindManyArgs, 'select' | 'include'> & {
      select?: GuruCountAggregateInputType | true
    }
  >

  export interface GuruDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Guru that matches the filter.
     * @param {GuruFindUniqueArgs} args - Arguments to find a Guru
     * @example
     * // Get one Guru
     * const guru = await prisma.guru.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuruFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuruFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Guru'> extends True ? CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>> : CheckSelect<T, Prisma__GuruClient<Guru | null >, Prisma__GuruClient<GuruGetPayload<T> | null >>

    /**
     * Find the first Guru that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruFindFirstArgs} args - Arguments to find a Guru
     * @example
     * // Get one Guru
     * const guru = await prisma.guru.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuruFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuruFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Guru'> extends True ? CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>> : CheckSelect<T, Prisma__GuruClient<Guru | null >, Prisma__GuruClient<GuruGetPayload<T> | null >>

    /**
     * Find zero or more Gurus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gurus
     * const gurus = await prisma.guru.findMany()
     * 
     * // Get first 10 Gurus
     * const gurus = await prisma.guru.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guruWithIdOnly = await prisma.guru.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GuruFindManyArgs>(
      args?: SelectSubset<T, GuruFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Guru>>, PrismaPromise<Array<GuruGetPayload<T>>>>

    /**
     * Create a Guru.
     * @param {GuruCreateArgs} args - Arguments to create a Guru.
     * @example
     * // Create one Guru
     * const Guru = await prisma.guru.create({
     *   data: {
     *     // ... data to create a Guru
     *   }
     * })
     * 
    **/
    create<T extends GuruCreateArgs>(
      args: SelectSubset<T, GuruCreateArgs>
    ): CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>>

    /**
     * Create many Gurus.
     *     @param {GuruCreateManyArgs} args - Arguments to create many Gurus.
     *     @example
     *     // Create many Gurus
     *     const guru = await prisma.guru.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuruCreateManyArgs>(
      args?: SelectSubset<T, GuruCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Guru.
     * @param {GuruDeleteArgs} args - Arguments to delete one Guru.
     * @example
     * // Delete one Guru
     * const Guru = await prisma.guru.delete({
     *   where: {
     *     // ... filter to delete one Guru
     *   }
     * })
     * 
    **/
    delete<T extends GuruDeleteArgs>(
      args: SelectSubset<T, GuruDeleteArgs>
    ): CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>>

    /**
     * Update one Guru.
     * @param {GuruUpdateArgs} args - Arguments to update one Guru.
     * @example
     * // Update one Guru
     * const guru = await prisma.guru.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuruUpdateArgs>(
      args: SelectSubset<T, GuruUpdateArgs>
    ): CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>>

    /**
     * Delete zero or more Gurus.
     * @param {GuruDeleteManyArgs} args - Arguments to filter Gurus to delete.
     * @example
     * // Delete a few Gurus
     * const { count } = await prisma.guru.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuruDeleteManyArgs>(
      args?: SelectSubset<T, GuruDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gurus
     * const guru = await prisma.guru.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuruUpdateManyArgs>(
      args: SelectSubset<T, GuruUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Guru.
     * @param {GuruUpsertArgs} args - Arguments to update or create a Guru.
     * @example
     * // Update or create a Guru
     * const guru = await prisma.guru.upsert({
     *   create: {
     *     // ... data to create a Guru
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guru we want to update
     *   }
     * })
    **/
    upsert<T extends GuruUpsertArgs>(
      args: SelectSubset<T, GuruUpsertArgs>
    ): CheckSelect<T, Prisma__GuruClient<Guru>, Prisma__GuruClient<GuruGetPayload<T>>>

    /**
     * Count the number of Gurus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruCountArgs} args - Arguments to filter Gurus to count.
     * @example
     * // Count the number of Gurus
     * const count = await prisma.guru.count({
     *   where: {
     *     // ... the filter for the Gurus we want to count
     *   }
     * })
    **/
    count<T extends GuruCountArgs>(
      args?: Subset<T, GuruCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuruCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guru.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuruAggregateArgs>(args: Subset<T, GuruAggregateArgs>): PrismaPromise<GetGuruAggregateType<T>>

    /**
     * Group by Guru.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuruGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuruGroupByArgs['orderBy'] }
        : { orderBy?: GuruGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuruGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuruGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guru.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuruClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guruDetails<T extends GuruDetailsArgs = {}>(args?: Subset<T, GuruDetailsArgs>): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails | null >, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Guru findUnique
   */
  export type GuruFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * Throw an Error if a Guru can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Guru to fetch.
     * 
    **/
    where: GuruWhereUniqueInput
  }


  /**
   * Guru findFirst
   */
  export type GuruFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * Throw an Error if a Guru can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Guru to fetch.
     * 
    **/
    where?: GuruWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gurus to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gurus.
     * 
    **/
    cursor?: GuruWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gurus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gurus.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gurus.
     * 
    **/
    distinct?: Enumerable<GuruScalarFieldEnum>
  }


  /**
   * Guru findMany
   */
  export type GuruFindManyArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * Filter, which Gurus to fetch.
     * 
    **/
    where?: GuruWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gurus to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gurus.
     * 
    **/
    cursor?: GuruWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gurus from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gurus.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuruScalarFieldEnum>
  }


  /**
   * Guru create
   */
  export type GuruCreateArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * The data needed to create a Guru.
     * 
    **/
    data: XOR<GuruCreateInput, GuruUncheckedCreateInput>
  }


  /**
   * Guru createMany
   */
  export type GuruCreateManyArgs = {
    data: Enumerable<GuruCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Guru update
   */
  export type GuruUpdateArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * The data needed to update a Guru.
     * 
    **/
    data: XOR<GuruUpdateInput, GuruUncheckedUpdateInput>
    /**
     * Choose, which Guru to update.
     * 
    **/
    where: GuruWhereUniqueInput
  }


  /**
   * Guru updateMany
   */
  export type GuruUpdateManyArgs = {
    data: XOR<GuruUpdateManyMutationInput, GuruUncheckedUpdateManyInput>
    where?: GuruWhereInput
  }


  /**
   * Guru upsert
   */
  export type GuruUpsertArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * The filter to search for the Guru to update in case it exists.
     * 
    **/
    where: GuruWhereUniqueInput
    /**
     * In case the Guru found by the `where` argument doesn't exist, create a new Guru with this data.
     * 
    **/
    create: XOR<GuruCreateInput, GuruUncheckedCreateInput>
    /**
     * In case the Guru was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuruUpdateInput, GuruUncheckedUpdateInput>
  }


  /**
   * Guru delete
   */
  export type GuruDeleteArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
    /**
     * Filter which Guru to delete.
     * 
    **/
    where: GuruWhereUniqueInput
  }


  /**
   * Guru deleteMany
   */
  export type GuruDeleteManyArgs = {
    where?: GuruWhereInput
  }


  /**
   * Guru without action
   */
  export type GuruArgs = {
    /**
     * Select specific fields to fetch from the Guru
     * 
    **/
    select?: GuruSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruInclude | null
  }



  /**
   * Model GuruDetails
   */


  export type AggregateGuruDetails = {
    _count: GuruDetailsCountAggregateOutputType | null
    _avg: GuruDetailsAvgAggregateOutputType | null
    _sum: GuruDetailsSumAggregateOutputType | null
    _min: GuruDetailsMinAggregateOutputType | null
    _max: GuruDetailsMaxAggregateOutputType | null
  }

  export type GuruDetailsAvgAggregateOutputType = {
    guruId: number | null
    userId: number | null
  }

  export type GuruDetailsSumAggregateOutputType = {
    guruId: number | null
    userId: number | null
  }

  export type GuruDetailsMinAggregateOutputType = {
    guruId: number | null
    userId: number | null
  }

  export type GuruDetailsMaxAggregateOutputType = {
    guruId: number | null
    userId: number | null
  }

  export type GuruDetailsCountAggregateOutputType = {
    guruId: number
    userId: number
    _all: number
  }


  export type GuruDetailsAvgAggregateInputType = {
    guruId?: true
    userId?: true
  }

  export type GuruDetailsSumAggregateInputType = {
    guruId?: true
    userId?: true
  }

  export type GuruDetailsMinAggregateInputType = {
    guruId?: true
    userId?: true
  }

  export type GuruDetailsMaxAggregateInputType = {
    guruId?: true
    userId?: true
  }

  export type GuruDetailsCountAggregateInputType = {
    guruId?: true
    userId?: true
    _all?: true
  }

  export type GuruDetailsAggregateArgs = {
    /**
     * Filter which GuruDetails to aggregate.
     * 
    **/
    where?: GuruDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuruDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuruDetails
    **/
    _count?: true | GuruDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuruDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuruDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuruDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuruDetailsMaxAggregateInputType
  }

  export type GetGuruDetailsAggregateType<T extends GuruDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuruDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuruDetails[P]>
      : GetScalarType<T[P], AggregateGuruDetails[P]>
  }


    
    
  export type GuruDetailsGroupByArgs = {
    where?: GuruDetailsWhereInput
    orderBy?: Enumerable<GuruDetailsOrderByWithAggregationInput>
    by: Array<GuruDetailsScalarFieldEnum>
    having?: GuruDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuruDetailsCountAggregateInputType | true
    _avg?: GuruDetailsAvgAggregateInputType
    _sum?: GuruDetailsSumAggregateInputType
    _min?: GuruDetailsMinAggregateInputType
    _max?: GuruDetailsMaxAggregateInputType
  }


  export type GuruDetailsGroupByOutputType = {
    guruId: number
    userId: number
    _count: GuruDetailsCountAggregateOutputType | null
    _avg: GuruDetailsAvgAggregateOutputType | null
    _sum: GuruDetailsSumAggregateOutputType | null
    _min: GuruDetailsMinAggregateOutputType | null
    _max: GuruDetailsMaxAggregateOutputType | null
  }

  type GetGuruDetailsGroupByPayload<T extends GuruDetailsGroupByArgs> = Promise<
    Array<
      PickArray<GuruDetailsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GuruDetailsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GuruDetailsGroupByOutputType[P]> 
            : GetScalarType<T[P], GuruDetailsGroupByOutputType[P]>
        }
      > 
    >


  export type GuruDetailsSelect = {
    guru?: boolean | GuruArgs
    guruId?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    guruTahfidzDetail?: boolean | GuruTahfidzDetailsArgs
  }

  export type GuruDetailsInclude = {
    guru?: boolean | GuruArgs
    user?: boolean | UserArgs
    guruTahfidzDetail?: boolean | GuruTahfidzDetailsArgs
  }

  export type GuruDetailsGetPayload<
    S extends boolean | null | undefined | GuruDetailsArgs,
    U = keyof S
      > = S extends true
        ? GuruDetails
    : S extends undefined
    ? never
    : S extends GuruDetailsArgs | GuruDetailsFindManyArgs
    ?'include' extends U
    ? GuruDetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guru'
        ? GuruGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'guruTahfidzDetail'
        ? GuruTahfidzDetailsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GuruDetails ?GuruDetails [P]
  : 
          P extends 'guru'
        ? GuruGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'guruTahfidzDetail'
        ? GuruTahfidzDetailsGetPayload<S['select'][P]> | null : never
  } 
    : GuruDetails
  : GuruDetails


  type GuruDetailsCountArgs = Merge<
    Omit<GuruDetailsFindManyArgs, 'select' | 'include'> & {
      select?: GuruDetailsCountAggregateInputType | true
    }
  >

  export interface GuruDetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GuruDetails that matches the filter.
     * @param {GuruDetailsFindUniqueArgs} args - Arguments to find a GuruDetails
     * @example
     * // Get one GuruDetails
     * const guruDetails = await prisma.guruDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuruDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuruDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GuruDetails'> extends True ? CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>> : CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails | null >, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T> | null >>

    /**
     * Find the first GuruDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsFindFirstArgs} args - Arguments to find a GuruDetails
     * @example
     * // Get one GuruDetails
     * const guruDetails = await prisma.guruDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuruDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuruDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GuruDetails'> extends True ? CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>> : CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails | null >, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T> | null >>

    /**
     * Find zero or more GuruDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuruDetails
     * const guruDetails = await prisma.guruDetails.findMany()
     * 
     * // Get first 10 GuruDetails
     * const guruDetails = await prisma.guruDetails.findMany({ take: 10 })
     * 
     * // Only select the `guruId`
     * const guruDetailsWithGuruIdOnly = await prisma.guruDetails.findMany({ select: { guruId: true } })
     * 
    **/
    findMany<T extends GuruDetailsFindManyArgs>(
      args?: SelectSubset<T, GuruDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GuruDetails>>, PrismaPromise<Array<GuruDetailsGetPayload<T>>>>

    /**
     * Create a GuruDetails.
     * @param {GuruDetailsCreateArgs} args - Arguments to create a GuruDetails.
     * @example
     * // Create one GuruDetails
     * const GuruDetails = await prisma.guruDetails.create({
     *   data: {
     *     // ... data to create a GuruDetails
     *   }
     * })
     * 
    **/
    create<T extends GuruDetailsCreateArgs>(
      args: SelectSubset<T, GuruDetailsCreateArgs>
    ): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>>

    /**
     * Create many GuruDetails.
     *     @param {GuruDetailsCreateManyArgs} args - Arguments to create many GuruDetails.
     *     @example
     *     // Create many GuruDetails
     *     const guruDetails = await prisma.guruDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuruDetailsCreateManyArgs>(
      args?: SelectSubset<T, GuruDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GuruDetails.
     * @param {GuruDetailsDeleteArgs} args - Arguments to delete one GuruDetails.
     * @example
     * // Delete one GuruDetails
     * const GuruDetails = await prisma.guruDetails.delete({
     *   where: {
     *     // ... filter to delete one GuruDetails
     *   }
     * })
     * 
    **/
    delete<T extends GuruDetailsDeleteArgs>(
      args: SelectSubset<T, GuruDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>>

    /**
     * Update one GuruDetails.
     * @param {GuruDetailsUpdateArgs} args - Arguments to update one GuruDetails.
     * @example
     * // Update one GuruDetails
     * const guruDetails = await prisma.guruDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuruDetailsUpdateArgs>(
      args: SelectSubset<T, GuruDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>>

    /**
     * Delete zero or more GuruDetails.
     * @param {GuruDetailsDeleteManyArgs} args - Arguments to filter GuruDetails to delete.
     * @example
     * // Delete a few GuruDetails
     * const { count } = await prisma.guruDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuruDetailsDeleteManyArgs>(
      args?: SelectSubset<T, GuruDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuruDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuruDetails
     * const guruDetails = await prisma.guruDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuruDetailsUpdateManyArgs>(
      args: SelectSubset<T, GuruDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GuruDetails.
     * @param {GuruDetailsUpsertArgs} args - Arguments to update or create a GuruDetails.
     * @example
     * // Update or create a GuruDetails
     * const guruDetails = await prisma.guruDetails.upsert({
     *   create: {
     *     // ... data to create a GuruDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuruDetails we want to update
     *   }
     * })
    **/
    upsert<T extends GuruDetailsUpsertArgs>(
      args: SelectSubset<T, GuruDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails>, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T>>>

    /**
     * Count the number of GuruDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsCountArgs} args - Arguments to filter GuruDetails to count.
     * @example
     * // Count the number of GuruDetails
     * const count = await prisma.guruDetails.count({
     *   where: {
     *     // ... the filter for the GuruDetails we want to count
     *   }
     * })
    **/
    count<T extends GuruDetailsCountArgs>(
      args?: Subset<T, GuruDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuruDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuruDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuruDetailsAggregateArgs>(args: Subset<T, GuruDetailsAggregateArgs>): PrismaPromise<GetGuruDetailsAggregateType<T>>

    /**
     * Group by GuruDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuruDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuruDetailsGroupByArgs['orderBy'] }
        : { orderBy?: GuruDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuruDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuruDetailsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuruDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuruDetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guru<T extends GuruArgs = {}>(args?: Subset<T, GuruArgs>): CheckSelect<T, Prisma__GuruClient<Guru | null >, Prisma__GuruClient<GuruGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    guruTahfidzDetail<T extends GuruTahfidzDetailsArgs = {}>(args?: Subset<T, GuruTahfidzDetailsArgs>): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails | null >, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GuruDetails findUnique
   */
  export type GuruDetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * Throw an Error if a GuruDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuruDetails to fetch.
     * 
    **/
    where: GuruDetailsWhereUniqueInput
  }


  /**
   * GuruDetails findFirst
   */
  export type GuruDetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * Throw an Error if a GuruDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuruDetails to fetch.
     * 
    **/
    where?: GuruDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuruDetails.
     * 
    **/
    cursor?: GuruDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuruDetails.
     * 
    **/
    distinct?: Enumerable<GuruDetailsScalarFieldEnum>
  }


  /**
   * GuruDetails findMany
   */
  export type GuruDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * Filter, which GuruDetails to fetch.
     * 
    **/
    where?: GuruDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuruDetails.
     * 
    **/
    cursor?: GuruDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuruDetailsScalarFieldEnum>
  }


  /**
   * GuruDetails create
   */
  export type GuruDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * The data needed to create a GuruDetails.
     * 
    **/
    data: XOR<GuruDetailsCreateInput, GuruDetailsUncheckedCreateInput>
  }


  /**
   * GuruDetails createMany
   */
  export type GuruDetailsCreateManyArgs = {
    data: Enumerable<GuruDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GuruDetails update
   */
  export type GuruDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * The data needed to update a GuruDetails.
     * 
    **/
    data: XOR<GuruDetailsUpdateInput, GuruDetailsUncheckedUpdateInput>
    /**
     * Choose, which GuruDetails to update.
     * 
    **/
    where: GuruDetailsWhereUniqueInput
  }


  /**
   * GuruDetails updateMany
   */
  export type GuruDetailsUpdateManyArgs = {
    data: XOR<GuruDetailsUpdateManyMutationInput, GuruDetailsUncheckedUpdateManyInput>
    where?: GuruDetailsWhereInput
  }


  /**
   * GuruDetails upsert
   */
  export type GuruDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * The filter to search for the GuruDetails to update in case it exists.
     * 
    **/
    where: GuruDetailsWhereUniqueInput
    /**
     * In case the GuruDetails found by the `where` argument doesn't exist, create a new GuruDetails with this data.
     * 
    **/
    create: XOR<GuruDetailsCreateInput, GuruDetailsUncheckedCreateInput>
    /**
     * In case the GuruDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuruDetailsUpdateInput, GuruDetailsUncheckedUpdateInput>
  }


  /**
   * GuruDetails delete
   */
  export type GuruDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
    /**
     * Filter which GuruDetails to delete.
     * 
    **/
    where: GuruDetailsWhereUniqueInput
  }


  /**
   * GuruDetails deleteMany
   */
  export type GuruDetailsDeleteManyArgs = {
    where?: GuruDetailsWhereInput
  }


  /**
   * GuruDetails without action
   */
  export type GuruDetailsArgs = {
    /**
     * Select specific fields to fetch from the GuruDetails
     * 
    **/
    select?: GuruDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruDetailsInclude | null
  }



  /**
   * Model GuruTahfidzDetails
   */


  export type AggregateGuruTahfidzDetails = {
    _count: GuruTahfidzDetailsCountAggregateOutputType | null
    _avg: GuruTahfidzDetailsAvgAggregateOutputType | null
    _sum: GuruTahfidzDetailsSumAggregateOutputType | null
    _min: GuruTahfidzDetailsMinAggregateOutputType | null
    _max: GuruTahfidzDetailsMaxAggregateOutputType | null
  }

  export type GuruTahfidzDetailsAvgAggregateOutputType = {
    guruId: number | null
  }

  export type GuruTahfidzDetailsSumAggregateOutputType = {
    guruId: number | null
  }

  export type GuruTahfidzDetailsMinAggregateOutputType = {
    guruId: number | null
    deleted: boolean | null
  }

  export type GuruTahfidzDetailsMaxAggregateOutputType = {
    guruId: number | null
    deleted: boolean | null
  }

  export type GuruTahfidzDetailsCountAggregateOutputType = {
    guruId: number
    deleted: number
    _all: number
  }


  export type GuruTahfidzDetailsAvgAggregateInputType = {
    guruId?: true
  }

  export type GuruTahfidzDetailsSumAggregateInputType = {
    guruId?: true
  }

  export type GuruTahfidzDetailsMinAggregateInputType = {
    guruId?: true
    deleted?: true
  }

  export type GuruTahfidzDetailsMaxAggregateInputType = {
    guruId?: true
    deleted?: true
  }

  export type GuruTahfidzDetailsCountAggregateInputType = {
    guruId?: true
    deleted?: true
    _all?: true
  }

  export type GuruTahfidzDetailsAggregateArgs = {
    /**
     * Filter which GuruTahfidzDetails to aggregate.
     * 
    **/
    where?: GuruTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: GuruTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruTahfidzDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuruTahfidzDetails
    **/
    _count?: true | GuruTahfidzDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuruTahfidzDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuruTahfidzDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuruTahfidzDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuruTahfidzDetailsMaxAggregateInputType
  }

  export type GetGuruTahfidzDetailsAggregateType<T extends GuruTahfidzDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuruTahfidzDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuruTahfidzDetails[P]>
      : GetScalarType<T[P], AggregateGuruTahfidzDetails[P]>
  }


    
    
  export type GuruTahfidzDetailsGroupByArgs = {
    where?: GuruTahfidzDetailsWhereInput
    orderBy?: Enumerable<GuruTahfidzDetailsOrderByWithAggregationInput>
    by: Array<GuruTahfidzDetailsScalarFieldEnum>
    having?: GuruTahfidzDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuruTahfidzDetailsCountAggregateInputType | true
    _avg?: GuruTahfidzDetailsAvgAggregateInputType
    _sum?: GuruTahfidzDetailsSumAggregateInputType
    _min?: GuruTahfidzDetailsMinAggregateInputType
    _max?: GuruTahfidzDetailsMaxAggregateInputType
  }


  export type GuruTahfidzDetailsGroupByOutputType = {
    guruId: number
    deleted: boolean
    _count: GuruTahfidzDetailsCountAggregateOutputType | null
    _avg: GuruTahfidzDetailsAvgAggregateOutputType | null
    _sum: GuruTahfidzDetailsSumAggregateOutputType | null
    _min: GuruTahfidzDetailsMinAggregateOutputType | null
    _max: GuruTahfidzDetailsMaxAggregateOutputType | null
  }

  type GetGuruTahfidzDetailsGroupByPayload<T extends GuruTahfidzDetailsGroupByArgs> = Promise<
    Array<
      PickArray<GuruTahfidzDetailsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof GuruTahfidzDetailsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], GuruTahfidzDetailsGroupByOutputType[P]> 
            : GetScalarType<T[P], GuruTahfidzDetailsGroupByOutputType[P]>
        }
      > 
    >


  export type GuruTahfidzDetailsSelect = {
    guruId?: boolean
    guruDetails?: boolean | GuruDetailsArgs
    deleted?: boolean
    kelompokTahfidz?: boolean | HalaqohFindManyArgs
    _count?: boolean | GuruTahfidzDetailsCountOutputTypeArgs
  }

  export type GuruTahfidzDetailsInclude = {
    guruDetails?: boolean | GuruDetailsArgs
    kelompokTahfidz?: boolean | HalaqohFindManyArgs
    _count?: boolean | GuruTahfidzDetailsCountOutputTypeArgs
  }

  export type GuruTahfidzDetailsGetPayload<
    S extends boolean | null | undefined | GuruTahfidzDetailsArgs,
    U = keyof S
      > = S extends true
        ? GuruTahfidzDetails
    : S extends undefined
    ? never
    : S extends GuruTahfidzDetailsArgs | GuruTahfidzDetailsFindManyArgs
    ?'include' extends U
    ? GuruTahfidzDetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guruDetails'
        ? GuruDetailsGetPayload<S['include'][P]> :
        P extends 'kelompokTahfidz'
        ? Array < HalaqohGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? GuruTahfidzDetailsCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof GuruTahfidzDetails ?GuruTahfidzDetails [P]
  : 
          P extends 'guruDetails'
        ? GuruDetailsGetPayload<S['select'][P]> :
        P extends 'kelompokTahfidz'
        ? Array < HalaqohGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? GuruTahfidzDetailsCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : GuruTahfidzDetails
  : GuruTahfidzDetails


  type GuruTahfidzDetailsCountArgs = Merge<
    Omit<GuruTahfidzDetailsFindManyArgs, 'select' | 'include'> & {
      select?: GuruTahfidzDetailsCountAggregateInputType | true
    }
  >

  export interface GuruTahfidzDetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one GuruTahfidzDetails that matches the filter.
     * @param {GuruTahfidzDetailsFindUniqueArgs} args - Arguments to find a GuruTahfidzDetails
     * @example
     * // Get one GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GuruTahfidzDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GuruTahfidzDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GuruTahfidzDetails'> extends True ? CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>> : CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails | null >, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T> | null >>

    /**
     * Find the first GuruTahfidzDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsFindFirstArgs} args - Arguments to find a GuruTahfidzDetails
     * @example
     * // Get one GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GuruTahfidzDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GuruTahfidzDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GuruTahfidzDetails'> extends True ? CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>> : CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails | null >, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T> | null >>

    /**
     * Find zero or more GuruTahfidzDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.findMany()
     * 
     * // Get first 10 GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.findMany({ take: 10 })
     * 
     * // Only select the `guruId`
     * const guruTahfidzDetailsWithGuruIdOnly = await prisma.guruTahfidzDetails.findMany({ select: { guruId: true } })
     * 
    **/
    findMany<T extends GuruTahfidzDetailsFindManyArgs>(
      args?: SelectSubset<T, GuruTahfidzDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<GuruTahfidzDetails>>, PrismaPromise<Array<GuruTahfidzDetailsGetPayload<T>>>>

    /**
     * Create a GuruTahfidzDetails.
     * @param {GuruTahfidzDetailsCreateArgs} args - Arguments to create a GuruTahfidzDetails.
     * @example
     * // Create one GuruTahfidzDetails
     * const GuruTahfidzDetails = await prisma.guruTahfidzDetails.create({
     *   data: {
     *     // ... data to create a GuruTahfidzDetails
     *   }
     * })
     * 
    **/
    create<T extends GuruTahfidzDetailsCreateArgs>(
      args: SelectSubset<T, GuruTahfidzDetailsCreateArgs>
    ): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>>

    /**
     * Create many GuruTahfidzDetails.
     *     @param {GuruTahfidzDetailsCreateManyArgs} args - Arguments to create many GuruTahfidzDetails.
     *     @example
     *     // Create many GuruTahfidzDetails
     *     const guruTahfidzDetails = await prisma.guruTahfidzDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GuruTahfidzDetailsCreateManyArgs>(
      args?: SelectSubset<T, GuruTahfidzDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a GuruTahfidzDetails.
     * @param {GuruTahfidzDetailsDeleteArgs} args - Arguments to delete one GuruTahfidzDetails.
     * @example
     * // Delete one GuruTahfidzDetails
     * const GuruTahfidzDetails = await prisma.guruTahfidzDetails.delete({
     *   where: {
     *     // ... filter to delete one GuruTahfidzDetails
     *   }
     * })
     * 
    **/
    delete<T extends GuruTahfidzDetailsDeleteArgs>(
      args: SelectSubset<T, GuruTahfidzDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>>

    /**
     * Update one GuruTahfidzDetails.
     * @param {GuruTahfidzDetailsUpdateArgs} args - Arguments to update one GuruTahfidzDetails.
     * @example
     * // Update one GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GuruTahfidzDetailsUpdateArgs>(
      args: SelectSubset<T, GuruTahfidzDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>>

    /**
     * Delete zero or more GuruTahfidzDetails.
     * @param {GuruTahfidzDetailsDeleteManyArgs} args - Arguments to filter GuruTahfidzDetails to delete.
     * @example
     * // Delete a few GuruTahfidzDetails
     * const { count } = await prisma.guruTahfidzDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GuruTahfidzDetailsDeleteManyArgs>(
      args?: SelectSubset<T, GuruTahfidzDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuruTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GuruTahfidzDetailsUpdateManyArgs>(
      args: SelectSubset<T, GuruTahfidzDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one GuruTahfidzDetails.
     * @param {GuruTahfidzDetailsUpsertArgs} args - Arguments to update or create a GuruTahfidzDetails.
     * @example
     * // Update or create a GuruTahfidzDetails
     * const guruTahfidzDetails = await prisma.guruTahfidzDetails.upsert({
     *   create: {
     *     // ... data to create a GuruTahfidzDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuruTahfidzDetails we want to update
     *   }
     * })
    **/
    upsert<T extends GuruTahfidzDetailsUpsertArgs>(
      args: SelectSubset<T, GuruTahfidzDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails>, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T>>>

    /**
     * Count the number of GuruTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsCountArgs} args - Arguments to filter GuruTahfidzDetails to count.
     * @example
     * // Count the number of GuruTahfidzDetails
     * const count = await prisma.guruTahfidzDetails.count({
     *   where: {
     *     // ... the filter for the GuruTahfidzDetails we want to count
     *   }
     * })
    **/
    count<T extends GuruTahfidzDetailsCountArgs>(
      args?: Subset<T, GuruTahfidzDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuruTahfidzDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuruTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuruTahfidzDetailsAggregateArgs>(args: Subset<T, GuruTahfidzDetailsAggregateArgs>): PrismaPromise<GetGuruTahfidzDetailsAggregateType<T>>

    /**
     * Group by GuruTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuruTahfidzDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuruTahfidzDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuruTahfidzDetailsGroupByArgs['orderBy'] }
        : { orderBy?: GuruTahfidzDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuruTahfidzDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuruTahfidzDetailsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuruTahfidzDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GuruTahfidzDetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guruDetails<T extends GuruDetailsArgs = {}>(args?: Subset<T, GuruDetailsArgs>): CheckSelect<T, Prisma__GuruDetailsClient<GuruDetails | null >, Prisma__GuruDetailsClient<GuruDetailsGetPayload<T> | null >>;

    kelompokTahfidz<T extends HalaqohFindManyArgs = {}>(args?: Subset<T, HalaqohFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Halaqoh>>, PrismaPromise<Array<HalaqohGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * GuruTahfidzDetails findUnique
   */
  export type GuruTahfidzDetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * Throw an Error if a GuruTahfidzDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuruTahfidzDetails to fetch.
     * 
    **/
    where: GuruTahfidzDetailsWhereUniqueInput
  }


  /**
   * GuruTahfidzDetails findFirst
   */
  export type GuruTahfidzDetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * Throw an Error if a GuruTahfidzDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which GuruTahfidzDetails to fetch.
     * 
    **/
    where?: GuruTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuruTahfidzDetails.
     * 
    **/
    cursor?: GuruTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruTahfidzDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuruTahfidzDetails.
     * 
    **/
    distinct?: Enumerable<GuruTahfidzDetailsScalarFieldEnum>
  }


  /**
   * GuruTahfidzDetails findMany
   */
  export type GuruTahfidzDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * Filter, which GuruTahfidzDetails to fetch.
     * 
    **/
    where?: GuruTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuruTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<GuruTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuruTahfidzDetails.
     * 
    **/
    cursor?: GuruTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuruTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuruTahfidzDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<GuruTahfidzDetailsScalarFieldEnum>
  }


  /**
   * GuruTahfidzDetails create
   */
  export type GuruTahfidzDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * The data needed to create a GuruTahfidzDetails.
     * 
    **/
    data: XOR<GuruTahfidzDetailsCreateInput, GuruTahfidzDetailsUncheckedCreateInput>
  }


  /**
   * GuruTahfidzDetails createMany
   */
  export type GuruTahfidzDetailsCreateManyArgs = {
    data: Enumerable<GuruTahfidzDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GuruTahfidzDetails update
   */
  export type GuruTahfidzDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * The data needed to update a GuruTahfidzDetails.
     * 
    **/
    data: XOR<GuruTahfidzDetailsUpdateInput, GuruTahfidzDetailsUncheckedUpdateInput>
    /**
     * Choose, which GuruTahfidzDetails to update.
     * 
    **/
    where: GuruTahfidzDetailsWhereUniqueInput
  }


  /**
   * GuruTahfidzDetails updateMany
   */
  export type GuruTahfidzDetailsUpdateManyArgs = {
    data: XOR<GuruTahfidzDetailsUpdateManyMutationInput, GuruTahfidzDetailsUncheckedUpdateManyInput>
    where?: GuruTahfidzDetailsWhereInput
  }


  /**
   * GuruTahfidzDetails upsert
   */
  export type GuruTahfidzDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * The filter to search for the GuruTahfidzDetails to update in case it exists.
     * 
    **/
    where: GuruTahfidzDetailsWhereUniqueInput
    /**
     * In case the GuruTahfidzDetails found by the `where` argument doesn't exist, create a new GuruTahfidzDetails with this data.
     * 
    **/
    create: XOR<GuruTahfidzDetailsCreateInput, GuruTahfidzDetailsUncheckedCreateInput>
    /**
     * In case the GuruTahfidzDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<GuruTahfidzDetailsUpdateInput, GuruTahfidzDetailsUncheckedUpdateInput>
  }


  /**
   * GuruTahfidzDetails delete
   */
  export type GuruTahfidzDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
    /**
     * Filter which GuruTahfidzDetails to delete.
     * 
    **/
    where: GuruTahfidzDetailsWhereUniqueInput
  }


  /**
   * GuruTahfidzDetails deleteMany
   */
  export type GuruTahfidzDetailsDeleteManyArgs = {
    where?: GuruTahfidzDetailsWhereInput
  }


  /**
   * GuruTahfidzDetails without action
   */
  export type GuruTahfidzDetailsArgs = {
    /**
     * Select specific fields to fetch from the GuruTahfidzDetails
     * 
    **/
    select?: GuruTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: GuruTahfidzDetailsInclude | null
  }



  /**
   * Model Murid
   */


  export type AggregateMurid = {
    _count: MuridCountAggregateOutputType | null
    _avg: MuridAvgAggregateOutputType | null
    _sum: MuridSumAggregateOutputType | null
    _min: MuridMinAggregateOutputType | null
    _max: MuridMaxAggregateOutputType | null
  }

  export type MuridAvgAggregateOutputType = {
    id: number | null
    anakKe: number | null
    jumlahSaudaraKandung: number | null
    jumlahSaudaraTiri: number | null
    jumlahSaudaraAngkat: number | null
  }

  export type MuridSumAggregateOutputType = {
    id: number | null
    anakKe: number | null
    jumlahSaudaraKandung: number | null
    jumlahSaudaraTiri: number | null
    jumlahSaudaraAngkat: number | null
  }

  export type MuridMinAggregateOutputType = {
    id: number | null
    nis: string | null
    nism: string | null
    nisn: string | null
    nama: string | null
    jenisKelamin: JenisKelamin | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    anakKe: number | null
    jumlahSaudaraKandung: number | null
    jumlahSaudaraTiri: number | null
    jumlahSaudaraAngkat: number | null
    golonganDarah: GolonganDarah | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type MuridMaxAggregateOutputType = {
    id: number | null
    nis: string | null
    nism: string | null
    nisn: string | null
    nama: string | null
    jenisKelamin: JenisKelamin | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    anakKe: number | null
    jumlahSaudaraKandung: number | null
    jumlahSaudaraTiri: number | null
    jumlahSaudaraAngkat: number | null
    golonganDarah: GolonganDarah | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type MuridCountAggregateOutputType = {
    id: number
    nis: number
    nism: number
    nisn: number
    nama: number
    jenisKelamin: number
    tempatLahir: number
    tanggalLahir: number
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah: number
    profileUrl: number
    deleted: number
    _all: number
  }


  export type MuridAvgAggregateInputType = {
    id?: true
    anakKe?: true
    jumlahSaudaraKandung?: true
    jumlahSaudaraTiri?: true
    jumlahSaudaraAngkat?: true
  }

  export type MuridSumAggregateInputType = {
    id?: true
    anakKe?: true
    jumlahSaudaraKandung?: true
    jumlahSaudaraTiri?: true
    jumlahSaudaraAngkat?: true
  }

  export type MuridMinAggregateInputType = {
    id?: true
    nis?: true
    nism?: true
    nisn?: true
    nama?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    anakKe?: true
    jumlahSaudaraKandung?: true
    jumlahSaudaraTiri?: true
    jumlahSaudaraAngkat?: true
    golonganDarah?: true
    profileUrl?: true
    deleted?: true
  }

  export type MuridMaxAggregateInputType = {
    id?: true
    nis?: true
    nism?: true
    nisn?: true
    nama?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    anakKe?: true
    jumlahSaudaraKandung?: true
    jumlahSaudaraTiri?: true
    jumlahSaudaraAngkat?: true
    golonganDarah?: true
    profileUrl?: true
    deleted?: true
  }

  export type MuridCountAggregateInputType = {
    id?: true
    nis?: true
    nism?: true
    nisn?: true
    nama?: true
    jenisKelamin?: true
    tempatLahir?: true
    tanggalLahir?: true
    anakKe?: true
    jumlahSaudaraKandung?: true
    jumlahSaudaraTiri?: true
    jumlahSaudaraAngkat?: true
    golonganDarah?: true
    profileUrl?: true
    deleted?: true
    _all?: true
  }

  export type MuridAggregateArgs = {
    /**
     * Filter which Murid to aggregate.
     * 
    **/
    where?: MuridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Murids to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MuridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Murids from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Murids.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Murids
    **/
    _count?: true | MuridCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuridAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuridSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuridMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuridMaxAggregateInputType
  }

  export type GetMuridAggregateType<T extends MuridAggregateArgs> = {
        [P in keyof T & keyof AggregateMurid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMurid[P]>
      : GetScalarType<T[P], AggregateMurid[P]>
  }


    
    
  export type MuridGroupByArgs = {
    where?: MuridWhereInput
    orderBy?: Enumerable<MuridOrderByWithAggregationInput>
    by: Array<MuridScalarFieldEnum>
    having?: MuridScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuridCountAggregateInputType | true
    _avg?: MuridAvgAggregateInputType
    _sum?: MuridSumAggregateInputType
    _min?: MuridMinAggregateInputType
    _max?: MuridMaxAggregateInputType
  }


  export type MuridGroupByOutputType = {
    id: number
    nis: string
    nism: string
    nisn: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah: GolonganDarah | null
    profileUrl: string | null
    deleted: boolean
    _count: MuridCountAggregateOutputType | null
    _avg: MuridAvgAggregateOutputType | null
    _sum: MuridSumAggregateOutputType | null
    _min: MuridMinAggregateOutputType | null
    _max: MuridMaxAggregateOutputType | null
  }

  type GetMuridGroupByPayload<T extends MuridGroupByArgs> = Promise<
    Array<
      PickArray<MuridGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MuridGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MuridGroupByOutputType[P]> 
            : GetScalarType<T[P], MuridGroupByOutputType[P]>
        }
      > 
    >


  export type MuridSelect = {
    id?: boolean
    nis?: boolean
    nism?: boolean
    nisn?: boolean
    nama?: boolean
    jenisKelamin?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    anakKe?: boolean
    jumlahSaudaraKandung?: boolean
    jumlahSaudaraTiri?: boolean
    jumlahSaudaraAngkat?: boolean
    golonganDarah?: boolean
    profileUrl?: boolean
    deleted?: boolean
    muridDetails?: boolean | MuridDetailsArgs
    orangTua?: boolean | ParentFindManyArgs
    _count?: boolean | MuridCountOutputTypeArgs
  }

  export type MuridInclude = {
    muridDetails?: boolean | MuridDetailsArgs
    orangTua?: boolean | ParentFindManyArgs
    _count?: boolean | MuridCountOutputTypeArgs
  }

  export type MuridGetPayload<
    S extends boolean | null | undefined | MuridArgs,
    U = keyof S
      > = S extends true
        ? Murid
    : S extends undefined
    ? never
    : S extends MuridArgs | MuridFindManyArgs
    ?'include' extends U
    ? Murid  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'muridDetails'
        ? MuridDetailsGetPayload<S['include'][P]> | null :
        P extends 'orangTua'
        ? Array < ParentGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? MuridCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Murid ?Murid [P]
  : 
          P extends 'muridDetails'
        ? MuridDetailsGetPayload<S['select'][P]> | null :
        P extends 'orangTua'
        ? Array < ParentGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? MuridCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Murid
  : Murid


  type MuridCountArgs = Merge<
    Omit<MuridFindManyArgs, 'select' | 'include'> & {
      select?: MuridCountAggregateInputType | true
    }
  >

  export interface MuridDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Murid that matches the filter.
     * @param {MuridFindUniqueArgs} args - Arguments to find a Murid
     * @example
     * // Get one Murid
     * const murid = await prisma.murid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuridFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MuridFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Murid'> extends True ? CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>> : CheckSelect<T, Prisma__MuridClient<Murid | null >, Prisma__MuridClient<MuridGetPayload<T> | null >>

    /**
     * Find the first Murid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridFindFirstArgs} args - Arguments to find a Murid
     * @example
     * // Get one Murid
     * const murid = await prisma.murid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuridFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MuridFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Murid'> extends True ? CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>> : CheckSelect<T, Prisma__MuridClient<Murid | null >, Prisma__MuridClient<MuridGetPayload<T> | null >>

    /**
     * Find zero or more Murids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Murids
     * const murids = await prisma.murid.findMany()
     * 
     * // Get first 10 Murids
     * const murids = await prisma.murid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const muridWithIdOnly = await prisma.murid.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MuridFindManyArgs>(
      args?: SelectSubset<T, MuridFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Murid>>, PrismaPromise<Array<MuridGetPayload<T>>>>

    /**
     * Create a Murid.
     * @param {MuridCreateArgs} args - Arguments to create a Murid.
     * @example
     * // Create one Murid
     * const Murid = await prisma.murid.create({
     *   data: {
     *     // ... data to create a Murid
     *   }
     * })
     * 
    **/
    create<T extends MuridCreateArgs>(
      args: SelectSubset<T, MuridCreateArgs>
    ): CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>>

    /**
     * Create many Murids.
     *     @param {MuridCreateManyArgs} args - Arguments to create many Murids.
     *     @example
     *     // Create many Murids
     *     const murid = await prisma.murid.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuridCreateManyArgs>(
      args?: SelectSubset<T, MuridCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Murid.
     * @param {MuridDeleteArgs} args - Arguments to delete one Murid.
     * @example
     * // Delete one Murid
     * const Murid = await prisma.murid.delete({
     *   where: {
     *     // ... filter to delete one Murid
     *   }
     * })
     * 
    **/
    delete<T extends MuridDeleteArgs>(
      args: SelectSubset<T, MuridDeleteArgs>
    ): CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>>

    /**
     * Update one Murid.
     * @param {MuridUpdateArgs} args - Arguments to update one Murid.
     * @example
     * // Update one Murid
     * const murid = await prisma.murid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuridUpdateArgs>(
      args: SelectSubset<T, MuridUpdateArgs>
    ): CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>>

    /**
     * Delete zero or more Murids.
     * @param {MuridDeleteManyArgs} args - Arguments to filter Murids to delete.
     * @example
     * // Delete a few Murids
     * const { count } = await prisma.murid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuridDeleteManyArgs>(
      args?: SelectSubset<T, MuridDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Murids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Murids
     * const murid = await prisma.murid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuridUpdateManyArgs>(
      args: SelectSubset<T, MuridUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Murid.
     * @param {MuridUpsertArgs} args - Arguments to update or create a Murid.
     * @example
     * // Update or create a Murid
     * const murid = await prisma.murid.upsert({
     *   create: {
     *     // ... data to create a Murid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Murid we want to update
     *   }
     * })
    **/
    upsert<T extends MuridUpsertArgs>(
      args: SelectSubset<T, MuridUpsertArgs>
    ): CheckSelect<T, Prisma__MuridClient<Murid>, Prisma__MuridClient<MuridGetPayload<T>>>

    /**
     * Count the number of Murids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridCountArgs} args - Arguments to filter Murids to count.
     * @example
     * // Count the number of Murids
     * const count = await prisma.murid.count({
     *   where: {
     *     // ... the filter for the Murids we want to count
     *   }
     * })
    **/
    count<T extends MuridCountArgs>(
      args?: Subset<T, MuridCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuridCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Murid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuridAggregateArgs>(args: Subset<T, MuridAggregateArgs>): PrismaPromise<GetMuridAggregateType<T>>

    /**
     * Group by Murid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuridGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuridGroupByArgs['orderBy'] }
        : { orderBy?: MuridGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuridGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuridGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Murid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MuridClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    muridDetails<T extends MuridDetailsArgs = {}>(args?: Subset<T, MuridDetailsArgs>): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails | null >, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T> | null >>;

    orangTua<T extends ParentFindManyArgs = {}>(args?: Subset<T, ParentFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Parent>>, PrismaPromise<Array<ParentGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Murid findUnique
   */
  export type MuridFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * Throw an Error if a Murid can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Murid to fetch.
     * 
    **/
    where: MuridWhereUniqueInput
  }


  /**
   * Murid findFirst
   */
  export type MuridFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * Throw an Error if a Murid can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Murid to fetch.
     * 
    **/
    where?: MuridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Murids to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Murids.
     * 
    **/
    cursor?: MuridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Murids from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Murids.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Murids.
     * 
    **/
    distinct?: Enumerable<MuridScalarFieldEnum>
  }


  /**
   * Murid findMany
   */
  export type MuridFindManyArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * Filter, which Murids to fetch.
     * 
    **/
    where?: MuridWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Murids to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Murids.
     * 
    **/
    cursor?: MuridWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Murids from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Murids.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MuridScalarFieldEnum>
  }


  /**
   * Murid create
   */
  export type MuridCreateArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * The data needed to create a Murid.
     * 
    **/
    data: XOR<MuridCreateInput, MuridUncheckedCreateInput>
  }


  /**
   * Murid createMany
   */
  export type MuridCreateManyArgs = {
    data: Enumerable<MuridCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Murid update
   */
  export type MuridUpdateArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * The data needed to update a Murid.
     * 
    **/
    data: XOR<MuridUpdateInput, MuridUncheckedUpdateInput>
    /**
     * Choose, which Murid to update.
     * 
    **/
    where: MuridWhereUniqueInput
  }


  /**
   * Murid updateMany
   */
  export type MuridUpdateManyArgs = {
    data: XOR<MuridUpdateManyMutationInput, MuridUncheckedUpdateManyInput>
    where?: MuridWhereInput
  }


  /**
   * Murid upsert
   */
  export type MuridUpsertArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * The filter to search for the Murid to update in case it exists.
     * 
    **/
    where: MuridWhereUniqueInput
    /**
     * In case the Murid found by the `where` argument doesn't exist, create a new Murid with this data.
     * 
    **/
    create: XOR<MuridCreateInput, MuridUncheckedCreateInput>
    /**
     * In case the Murid was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MuridUpdateInput, MuridUncheckedUpdateInput>
  }


  /**
   * Murid delete
   */
  export type MuridDeleteArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
    /**
     * Filter which Murid to delete.
     * 
    **/
    where: MuridWhereUniqueInput
  }


  /**
   * Murid deleteMany
   */
  export type MuridDeleteManyArgs = {
    where?: MuridWhereInput
  }


  /**
   * Murid without action
   */
  export type MuridArgs = {
    /**
     * Select specific fields to fetch from the Murid
     * 
    **/
    select?: MuridSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridInclude | null
  }



  /**
   * Model MuridDetails
   */


  export type AggregateMuridDetails = {
    _count: MuridDetailsCountAggregateOutputType | null
    _avg: MuridDetailsAvgAggregateOutputType | null
    _sum: MuridDetailsSumAggregateOutputType | null
    _min: MuridDetailsMinAggregateOutputType | null
    _max: MuridDetailsMaxAggregateOutputType | null
  }

  export type MuridDetailsAvgAggregateOutputType = {
    muridId: number | null
    userId: number | null
  }

  export type MuridDetailsSumAggregateOutputType = {
    muridId: number | null
    userId: number | null
  }

  export type MuridDetailsMinAggregateOutputType = {
    muridId: number | null
    userId: number | null
  }

  export type MuridDetailsMaxAggregateOutputType = {
    muridId: number | null
    userId: number | null
  }

  export type MuridDetailsCountAggregateOutputType = {
    muridId: number
    userId: number
    _all: number
  }


  export type MuridDetailsAvgAggregateInputType = {
    muridId?: true
    userId?: true
  }

  export type MuridDetailsSumAggregateInputType = {
    muridId?: true
    userId?: true
  }

  export type MuridDetailsMinAggregateInputType = {
    muridId?: true
    userId?: true
  }

  export type MuridDetailsMaxAggregateInputType = {
    muridId?: true
    userId?: true
  }

  export type MuridDetailsCountAggregateInputType = {
    muridId?: true
    userId?: true
    _all?: true
  }

  export type MuridDetailsAggregateArgs = {
    /**
     * Filter which MuridDetails to aggregate.
     * 
    **/
    where?: MuridDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MuridDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuridDetails
    **/
    _count?: true | MuridDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuridDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuridDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuridDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuridDetailsMaxAggregateInputType
  }

  export type GetMuridDetailsAggregateType<T extends MuridDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateMuridDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuridDetails[P]>
      : GetScalarType<T[P], AggregateMuridDetails[P]>
  }


    
    
  export type MuridDetailsGroupByArgs = {
    where?: MuridDetailsWhereInput
    orderBy?: Enumerable<MuridDetailsOrderByWithAggregationInput>
    by: Array<MuridDetailsScalarFieldEnum>
    having?: MuridDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuridDetailsCountAggregateInputType | true
    _avg?: MuridDetailsAvgAggregateInputType
    _sum?: MuridDetailsSumAggregateInputType
    _min?: MuridDetailsMinAggregateInputType
    _max?: MuridDetailsMaxAggregateInputType
  }


  export type MuridDetailsGroupByOutputType = {
    muridId: number
    userId: number
    _count: MuridDetailsCountAggregateOutputType | null
    _avg: MuridDetailsAvgAggregateOutputType | null
    _sum: MuridDetailsSumAggregateOutputType | null
    _min: MuridDetailsMinAggregateOutputType | null
    _max: MuridDetailsMaxAggregateOutputType | null
  }

  type GetMuridDetailsGroupByPayload<T extends MuridDetailsGroupByArgs> = Promise<
    Array<
      PickArray<MuridDetailsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MuridDetailsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MuridDetailsGroupByOutputType[P]> 
            : GetScalarType<T[P], MuridDetailsGroupByOutputType[P]>
        }
      > 
    >


  export type MuridDetailsSelect = {
    muridId?: boolean
    murid?: boolean | MuridArgs
    userId?: boolean
    user?: boolean | UserArgs
    tahfidzDetails?: boolean | MuridTahfidzDetailsArgs
  }

  export type MuridDetailsInclude = {
    murid?: boolean | MuridArgs
    user?: boolean | UserArgs
    tahfidzDetails?: boolean | MuridTahfidzDetailsArgs
  }

  export type MuridDetailsGetPayload<
    S extends boolean | null | undefined | MuridDetailsArgs,
    U = keyof S
      > = S extends true
        ? MuridDetails
    : S extends undefined
    ? never
    : S extends MuridDetailsArgs | MuridDetailsFindManyArgs
    ?'include' extends U
    ? MuridDetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'murid'
        ? MuridGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'tahfidzDetails'
        ? MuridTahfidzDetailsGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MuridDetails ?MuridDetails [P]
  : 
          P extends 'murid'
        ? MuridGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'tahfidzDetails'
        ? MuridTahfidzDetailsGetPayload<S['select'][P]> | null : never
  } 
    : MuridDetails
  : MuridDetails


  type MuridDetailsCountArgs = Merge<
    Omit<MuridDetailsFindManyArgs, 'select' | 'include'> & {
      select?: MuridDetailsCountAggregateInputType | true
    }
  >

  export interface MuridDetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MuridDetails that matches the filter.
     * @param {MuridDetailsFindUniqueArgs} args - Arguments to find a MuridDetails
     * @example
     * // Get one MuridDetails
     * const muridDetails = await prisma.muridDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuridDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MuridDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MuridDetails'> extends True ? CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>> : CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails | null >, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T> | null >>

    /**
     * Find the first MuridDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsFindFirstArgs} args - Arguments to find a MuridDetails
     * @example
     * // Get one MuridDetails
     * const muridDetails = await prisma.muridDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuridDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MuridDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MuridDetails'> extends True ? CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>> : CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails | null >, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T> | null >>

    /**
     * Find zero or more MuridDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuridDetails
     * const muridDetails = await prisma.muridDetails.findMany()
     * 
     * // Get first 10 MuridDetails
     * const muridDetails = await prisma.muridDetails.findMany({ take: 10 })
     * 
     * // Only select the `muridId`
     * const muridDetailsWithMuridIdOnly = await prisma.muridDetails.findMany({ select: { muridId: true } })
     * 
    **/
    findMany<T extends MuridDetailsFindManyArgs>(
      args?: SelectSubset<T, MuridDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MuridDetails>>, PrismaPromise<Array<MuridDetailsGetPayload<T>>>>

    /**
     * Create a MuridDetails.
     * @param {MuridDetailsCreateArgs} args - Arguments to create a MuridDetails.
     * @example
     * // Create one MuridDetails
     * const MuridDetails = await prisma.muridDetails.create({
     *   data: {
     *     // ... data to create a MuridDetails
     *   }
     * })
     * 
    **/
    create<T extends MuridDetailsCreateArgs>(
      args: SelectSubset<T, MuridDetailsCreateArgs>
    ): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>>

    /**
     * Create many MuridDetails.
     *     @param {MuridDetailsCreateManyArgs} args - Arguments to create many MuridDetails.
     *     @example
     *     // Create many MuridDetails
     *     const muridDetails = await prisma.muridDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuridDetailsCreateManyArgs>(
      args?: SelectSubset<T, MuridDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MuridDetails.
     * @param {MuridDetailsDeleteArgs} args - Arguments to delete one MuridDetails.
     * @example
     * // Delete one MuridDetails
     * const MuridDetails = await prisma.muridDetails.delete({
     *   where: {
     *     // ... filter to delete one MuridDetails
     *   }
     * })
     * 
    **/
    delete<T extends MuridDetailsDeleteArgs>(
      args: SelectSubset<T, MuridDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>>

    /**
     * Update one MuridDetails.
     * @param {MuridDetailsUpdateArgs} args - Arguments to update one MuridDetails.
     * @example
     * // Update one MuridDetails
     * const muridDetails = await prisma.muridDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuridDetailsUpdateArgs>(
      args: SelectSubset<T, MuridDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>>

    /**
     * Delete zero or more MuridDetails.
     * @param {MuridDetailsDeleteManyArgs} args - Arguments to filter MuridDetails to delete.
     * @example
     * // Delete a few MuridDetails
     * const { count } = await prisma.muridDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuridDetailsDeleteManyArgs>(
      args?: SelectSubset<T, MuridDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuridDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuridDetails
     * const muridDetails = await prisma.muridDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuridDetailsUpdateManyArgs>(
      args: SelectSubset<T, MuridDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MuridDetails.
     * @param {MuridDetailsUpsertArgs} args - Arguments to update or create a MuridDetails.
     * @example
     * // Update or create a MuridDetails
     * const muridDetails = await prisma.muridDetails.upsert({
     *   create: {
     *     // ... data to create a MuridDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuridDetails we want to update
     *   }
     * })
    **/
    upsert<T extends MuridDetailsUpsertArgs>(
      args: SelectSubset<T, MuridDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails>, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T>>>

    /**
     * Count the number of MuridDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsCountArgs} args - Arguments to filter MuridDetails to count.
     * @example
     * // Count the number of MuridDetails
     * const count = await prisma.muridDetails.count({
     *   where: {
     *     // ... the filter for the MuridDetails we want to count
     *   }
     * })
    **/
    count<T extends MuridDetailsCountArgs>(
      args?: Subset<T, MuridDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuridDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuridDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuridDetailsAggregateArgs>(args: Subset<T, MuridDetailsAggregateArgs>): PrismaPromise<GetMuridDetailsAggregateType<T>>

    /**
     * Group by MuridDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuridDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuridDetailsGroupByArgs['orderBy'] }
        : { orderBy?: MuridDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuridDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuridDetailsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuridDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MuridDetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    murid<T extends MuridArgs = {}>(args?: Subset<T, MuridArgs>): CheckSelect<T, Prisma__MuridClient<Murid | null >, Prisma__MuridClient<MuridGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    tahfidzDetails<T extends MuridTahfidzDetailsArgs = {}>(args?: Subset<T, MuridTahfidzDetailsArgs>): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails | null >, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MuridDetails findUnique
   */
  export type MuridDetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * Throw an Error if a MuridDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MuridDetails to fetch.
     * 
    **/
    where: MuridDetailsWhereUniqueInput
  }


  /**
   * MuridDetails findFirst
   */
  export type MuridDetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * Throw an Error if a MuridDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MuridDetails to fetch.
     * 
    **/
    where?: MuridDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuridDetails.
     * 
    **/
    cursor?: MuridDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuridDetails.
     * 
    **/
    distinct?: Enumerable<MuridDetailsScalarFieldEnum>
  }


  /**
   * MuridDetails findMany
   */
  export type MuridDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * Filter, which MuridDetails to fetch.
     * 
    **/
    where?: MuridDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuridDetails.
     * 
    **/
    cursor?: MuridDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MuridDetailsScalarFieldEnum>
  }


  /**
   * MuridDetails create
   */
  export type MuridDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * The data needed to create a MuridDetails.
     * 
    **/
    data: XOR<MuridDetailsCreateInput, MuridDetailsUncheckedCreateInput>
  }


  /**
   * MuridDetails createMany
   */
  export type MuridDetailsCreateManyArgs = {
    data: Enumerable<MuridDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MuridDetails update
   */
  export type MuridDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * The data needed to update a MuridDetails.
     * 
    **/
    data: XOR<MuridDetailsUpdateInput, MuridDetailsUncheckedUpdateInput>
    /**
     * Choose, which MuridDetails to update.
     * 
    **/
    where: MuridDetailsWhereUniqueInput
  }


  /**
   * MuridDetails updateMany
   */
  export type MuridDetailsUpdateManyArgs = {
    data: XOR<MuridDetailsUpdateManyMutationInput, MuridDetailsUncheckedUpdateManyInput>
    where?: MuridDetailsWhereInput
  }


  /**
   * MuridDetails upsert
   */
  export type MuridDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * The filter to search for the MuridDetails to update in case it exists.
     * 
    **/
    where: MuridDetailsWhereUniqueInput
    /**
     * In case the MuridDetails found by the `where` argument doesn't exist, create a new MuridDetails with this data.
     * 
    **/
    create: XOR<MuridDetailsCreateInput, MuridDetailsUncheckedCreateInput>
    /**
     * In case the MuridDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MuridDetailsUpdateInput, MuridDetailsUncheckedUpdateInput>
  }


  /**
   * MuridDetails delete
   */
  export type MuridDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
    /**
     * Filter which MuridDetails to delete.
     * 
    **/
    where: MuridDetailsWhereUniqueInput
  }


  /**
   * MuridDetails deleteMany
   */
  export type MuridDetailsDeleteManyArgs = {
    where?: MuridDetailsWhereInput
  }


  /**
   * MuridDetails without action
   */
  export type MuridDetailsArgs = {
    /**
     * Select specific fields to fetch from the MuridDetails
     * 
    **/
    select?: MuridDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridDetailsInclude | null
  }



  /**
   * Model MuridTahfidzDetails
   */


  export type AggregateMuridTahfidzDetails = {
    _count: MuridTahfidzDetailsCountAggregateOutputType | null
    _avg: MuridTahfidzDetailsAvgAggregateOutputType | null
    _sum: MuridTahfidzDetailsSumAggregateOutputType | null
    _min: MuridTahfidzDetailsMinAggregateOutputType | null
    _max: MuridTahfidzDetailsMaxAggregateOutputType | null
  }

  export type MuridTahfidzDetailsAvgAggregateOutputType = {
    muridId: number | null
    kelompokTahfidzId: number | null
  }

  export type MuridTahfidzDetailsSumAggregateOutputType = {
    muridId: number | null
    kelompokTahfidzId: number | null
  }

  export type MuridTahfidzDetailsMinAggregateOutputType = {
    muridId: number | null
    kelompokTahfidzId: number | null
  }

  export type MuridTahfidzDetailsMaxAggregateOutputType = {
    muridId: number | null
    kelompokTahfidzId: number | null
  }

  export type MuridTahfidzDetailsCountAggregateOutputType = {
    muridId: number
    kelompokTahfidzId: number
    _all: number
  }


  export type MuridTahfidzDetailsAvgAggregateInputType = {
    muridId?: true
    kelompokTahfidzId?: true
  }

  export type MuridTahfidzDetailsSumAggregateInputType = {
    muridId?: true
    kelompokTahfidzId?: true
  }

  export type MuridTahfidzDetailsMinAggregateInputType = {
    muridId?: true
    kelompokTahfidzId?: true
  }

  export type MuridTahfidzDetailsMaxAggregateInputType = {
    muridId?: true
    kelompokTahfidzId?: true
  }

  export type MuridTahfidzDetailsCountAggregateInputType = {
    muridId?: true
    kelompokTahfidzId?: true
    _all?: true
  }

  export type MuridTahfidzDetailsAggregateArgs = {
    /**
     * Filter which MuridTahfidzDetails to aggregate.
     * 
    **/
    where?: MuridTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MuridTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridTahfidzDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MuridTahfidzDetails
    **/
    _count?: true | MuridTahfidzDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MuridTahfidzDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MuridTahfidzDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuridTahfidzDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuridTahfidzDetailsMaxAggregateInputType
  }

  export type GetMuridTahfidzDetailsAggregateType<T extends MuridTahfidzDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateMuridTahfidzDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMuridTahfidzDetails[P]>
      : GetScalarType<T[P], AggregateMuridTahfidzDetails[P]>
  }


    
    
  export type MuridTahfidzDetailsGroupByArgs = {
    where?: MuridTahfidzDetailsWhereInput
    orderBy?: Enumerable<MuridTahfidzDetailsOrderByWithAggregationInput>
    by: Array<MuridTahfidzDetailsScalarFieldEnum>
    having?: MuridTahfidzDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuridTahfidzDetailsCountAggregateInputType | true
    _avg?: MuridTahfidzDetailsAvgAggregateInputType
    _sum?: MuridTahfidzDetailsSumAggregateInputType
    _min?: MuridTahfidzDetailsMinAggregateInputType
    _max?: MuridTahfidzDetailsMaxAggregateInputType
  }


  export type MuridTahfidzDetailsGroupByOutputType = {
    muridId: number
    kelompokTahfidzId: number
    _count: MuridTahfidzDetailsCountAggregateOutputType | null
    _avg: MuridTahfidzDetailsAvgAggregateOutputType | null
    _sum: MuridTahfidzDetailsSumAggregateOutputType | null
    _min: MuridTahfidzDetailsMinAggregateOutputType | null
    _max: MuridTahfidzDetailsMaxAggregateOutputType | null
  }

  type GetMuridTahfidzDetailsGroupByPayload<T extends MuridTahfidzDetailsGroupByArgs> = Promise<
    Array<
      PickArray<MuridTahfidzDetailsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof MuridTahfidzDetailsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], MuridTahfidzDetailsGroupByOutputType[P]> 
            : GetScalarType<T[P], MuridTahfidzDetailsGroupByOutputType[P]>
        }
      > 
    >


  export type MuridTahfidzDetailsSelect = {
    muridId?: boolean
    muridDetails?: boolean | MuridDetailsArgs
    kelompokTahfidzId?: boolean
    kelompokTahfidz?: boolean | HalaqohArgs
    sesi?: boolean | SessionFindManyArgs
    _count?: boolean | MuridTahfidzDetailsCountOutputTypeArgs
  }

  export type MuridTahfidzDetailsInclude = {
    muridDetails?: boolean | MuridDetailsArgs
    kelompokTahfidz?: boolean | HalaqohArgs
    sesi?: boolean | SessionFindManyArgs
    _count?: boolean | MuridTahfidzDetailsCountOutputTypeArgs
  }

  export type MuridTahfidzDetailsGetPayload<
    S extends boolean | null | undefined | MuridTahfidzDetailsArgs,
    U = keyof S
      > = S extends true
        ? MuridTahfidzDetails
    : S extends undefined
    ? never
    : S extends MuridTahfidzDetailsArgs | MuridTahfidzDetailsFindManyArgs
    ?'include' extends U
    ? MuridTahfidzDetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'muridDetails'
        ? MuridDetailsGetPayload<S['include'][P]> :
        P extends 'kelompokTahfidz'
        ? HalaqohGetPayload<S['include'][P]> :
        P extends 'sesi'
        ? Array < SessionGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? MuridTahfidzDetailsCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MuridTahfidzDetails ?MuridTahfidzDetails [P]
  : 
          P extends 'muridDetails'
        ? MuridDetailsGetPayload<S['select'][P]> :
        P extends 'kelompokTahfidz'
        ? HalaqohGetPayload<S['select'][P]> :
        P extends 'sesi'
        ? Array < SessionGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? MuridTahfidzDetailsCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : MuridTahfidzDetails
  : MuridTahfidzDetails


  type MuridTahfidzDetailsCountArgs = Merge<
    Omit<MuridTahfidzDetailsFindManyArgs, 'select' | 'include'> & {
      select?: MuridTahfidzDetailsCountAggregateInputType | true
    }
  >

  export interface MuridTahfidzDetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MuridTahfidzDetails that matches the filter.
     * @param {MuridTahfidzDetailsFindUniqueArgs} args - Arguments to find a MuridTahfidzDetails
     * @example
     * // Get one MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MuridTahfidzDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MuridTahfidzDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MuridTahfidzDetails'> extends True ? CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>> : CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails | null >, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T> | null >>

    /**
     * Find the first MuridTahfidzDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsFindFirstArgs} args - Arguments to find a MuridTahfidzDetails
     * @example
     * // Get one MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MuridTahfidzDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MuridTahfidzDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MuridTahfidzDetails'> extends True ? CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>> : CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails | null >, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T> | null >>

    /**
     * Find zero or more MuridTahfidzDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.findMany()
     * 
     * // Get first 10 MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.findMany({ take: 10 })
     * 
     * // Only select the `muridId`
     * const muridTahfidzDetailsWithMuridIdOnly = await prisma.muridTahfidzDetails.findMany({ select: { muridId: true } })
     * 
    **/
    findMany<T extends MuridTahfidzDetailsFindManyArgs>(
      args?: SelectSubset<T, MuridTahfidzDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MuridTahfidzDetails>>, PrismaPromise<Array<MuridTahfidzDetailsGetPayload<T>>>>

    /**
     * Create a MuridTahfidzDetails.
     * @param {MuridTahfidzDetailsCreateArgs} args - Arguments to create a MuridTahfidzDetails.
     * @example
     * // Create one MuridTahfidzDetails
     * const MuridTahfidzDetails = await prisma.muridTahfidzDetails.create({
     *   data: {
     *     // ... data to create a MuridTahfidzDetails
     *   }
     * })
     * 
    **/
    create<T extends MuridTahfidzDetailsCreateArgs>(
      args: SelectSubset<T, MuridTahfidzDetailsCreateArgs>
    ): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>>

    /**
     * Create many MuridTahfidzDetails.
     *     @param {MuridTahfidzDetailsCreateManyArgs} args - Arguments to create many MuridTahfidzDetails.
     *     @example
     *     // Create many MuridTahfidzDetails
     *     const muridTahfidzDetails = await prisma.muridTahfidzDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MuridTahfidzDetailsCreateManyArgs>(
      args?: SelectSubset<T, MuridTahfidzDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MuridTahfidzDetails.
     * @param {MuridTahfidzDetailsDeleteArgs} args - Arguments to delete one MuridTahfidzDetails.
     * @example
     * // Delete one MuridTahfidzDetails
     * const MuridTahfidzDetails = await prisma.muridTahfidzDetails.delete({
     *   where: {
     *     // ... filter to delete one MuridTahfidzDetails
     *   }
     * })
     * 
    **/
    delete<T extends MuridTahfidzDetailsDeleteArgs>(
      args: SelectSubset<T, MuridTahfidzDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>>

    /**
     * Update one MuridTahfidzDetails.
     * @param {MuridTahfidzDetailsUpdateArgs} args - Arguments to update one MuridTahfidzDetails.
     * @example
     * // Update one MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MuridTahfidzDetailsUpdateArgs>(
      args: SelectSubset<T, MuridTahfidzDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>>

    /**
     * Delete zero or more MuridTahfidzDetails.
     * @param {MuridTahfidzDetailsDeleteManyArgs} args - Arguments to filter MuridTahfidzDetails to delete.
     * @example
     * // Delete a few MuridTahfidzDetails
     * const { count } = await prisma.muridTahfidzDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MuridTahfidzDetailsDeleteManyArgs>(
      args?: SelectSubset<T, MuridTahfidzDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MuridTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MuridTahfidzDetailsUpdateManyArgs>(
      args: SelectSubset<T, MuridTahfidzDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MuridTahfidzDetails.
     * @param {MuridTahfidzDetailsUpsertArgs} args - Arguments to update or create a MuridTahfidzDetails.
     * @example
     * // Update or create a MuridTahfidzDetails
     * const muridTahfidzDetails = await prisma.muridTahfidzDetails.upsert({
     *   create: {
     *     // ... data to create a MuridTahfidzDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MuridTahfidzDetails we want to update
     *   }
     * })
    **/
    upsert<T extends MuridTahfidzDetailsUpsertArgs>(
      args: SelectSubset<T, MuridTahfidzDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails>, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T>>>

    /**
     * Count the number of MuridTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsCountArgs} args - Arguments to filter MuridTahfidzDetails to count.
     * @example
     * // Count the number of MuridTahfidzDetails
     * const count = await prisma.muridTahfidzDetails.count({
     *   where: {
     *     // ... the filter for the MuridTahfidzDetails we want to count
     *   }
     * })
    **/
    count<T extends MuridTahfidzDetailsCountArgs>(
      args?: Subset<T, MuridTahfidzDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuridTahfidzDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MuridTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuridTahfidzDetailsAggregateArgs>(args: Subset<T, MuridTahfidzDetailsAggregateArgs>): PrismaPromise<GetMuridTahfidzDetailsAggregateType<T>>

    /**
     * Group by MuridTahfidzDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuridTahfidzDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuridTahfidzDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuridTahfidzDetailsGroupByArgs['orderBy'] }
        : { orderBy?: MuridTahfidzDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuridTahfidzDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuridTahfidzDetailsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MuridTahfidzDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MuridTahfidzDetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    muridDetails<T extends MuridDetailsArgs = {}>(args?: Subset<T, MuridDetailsArgs>): CheckSelect<T, Prisma__MuridDetailsClient<MuridDetails | null >, Prisma__MuridDetailsClient<MuridDetailsGetPayload<T> | null >>;

    kelompokTahfidz<T extends HalaqohArgs = {}>(args?: Subset<T, HalaqohArgs>): CheckSelect<T, Prisma__HalaqohClient<Halaqoh | null >, Prisma__HalaqohClient<HalaqohGetPayload<T> | null >>;

    sesi<T extends SessionFindManyArgs = {}>(args?: Subset<T, SessionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MuridTahfidzDetails findUnique
   */
  export type MuridTahfidzDetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * Throw an Error if a MuridTahfidzDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MuridTahfidzDetails to fetch.
     * 
    **/
    where: MuridTahfidzDetailsWhereUniqueInput
  }


  /**
   * MuridTahfidzDetails findFirst
   */
  export type MuridTahfidzDetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * Throw an Error if a MuridTahfidzDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MuridTahfidzDetails to fetch.
     * 
    **/
    where?: MuridTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MuridTahfidzDetails.
     * 
    **/
    cursor?: MuridTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridTahfidzDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MuridTahfidzDetails.
     * 
    **/
    distinct?: Enumerable<MuridTahfidzDetailsScalarFieldEnum>
  }


  /**
   * MuridTahfidzDetails findMany
   */
  export type MuridTahfidzDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * Filter, which MuridTahfidzDetails to fetch.
     * 
    **/
    where?: MuridTahfidzDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MuridTahfidzDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<MuridTahfidzDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MuridTahfidzDetails.
     * 
    **/
    cursor?: MuridTahfidzDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MuridTahfidzDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MuridTahfidzDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MuridTahfidzDetailsScalarFieldEnum>
  }


  /**
   * MuridTahfidzDetails create
   */
  export type MuridTahfidzDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * The data needed to create a MuridTahfidzDetails.
     * 
    **/
    data: XOR<MuridTahfidzDetailsCreateInput, MuridTahfidzDetailsUncheckedCreateInput>
  }


  /**
   * MuridTahfidzDetails createMany
   */
  export type MuridTahfidzDetailsCreateManyArgs = {
    data: Enumerable<MuridTahfidzDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MuridTahfidzDetails update
   */
  export type MuridTahfidzDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * The data needed to update a MuridTahfidzDetails.
     * 
    **/
    data: XOR<MuridTahfidzDetailsUpdateInput, MuridTahfidzDetailsUncheckedUpdateInput>
    /**
     * Choose, which MuridTahfidzDetails to update.
     * 
    **/
    where: MuridTahfidzDetailsWhereUniqueInput
  }


  /**
   * MuridTahfidzDetails updateMany
   */
  export type MuridTahfidzDetailsUpdateManyArgs = {
    data: XOR<MuridTahfidzDetailsUpdateManyMutationInput, MuridTahfidzDetailsUncheckedUpdateManyInput>
    where?: MuridTahfidzDetailsWhereInput
  }


  /**
   * MuridTahfidzDetails upsert
   */
  export type MuridTahfidzDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * The filter to search for the MuridTahfidzDetails to update in case it exists.
     * 
    **/
    where: MuridTahfidzDetailsWhereUniqueInput
    /**
     * In case the MuridTahfidzDetails found by the `where` argument doesn't exist, create a new MuridTahfidzDetails with this data.
     * 
    **/
    create: XOR<MuridTahfidzDetailsCreateInput, MuridTahfidzDetailsUncheckedCreateInput>
    /**
     * In case the MuridTahfidzDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MuridTahfidzDetailsUpdateInput, MuridTahfidzDetailsUncheckedUpdateInput>
  }


  /**
   * MuridTahfidzDetails delete
   */
  export type MuridTahfidzDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
    /**
     * Filter which MuridTahfidzDetails to delete.
     * 
    **/
    where: MuridTahfidzDetailsWhereUniqueInput
  }


  /**
   * MuridTahfidzDetails deleteMany
   */
  export type MuridTahfidzDetailsDeleteManyArgs = {
    where?: MuridTahfidzDetailsWhereInput
  }


  /**
   * MuridTahfidzDetails without action
   */
  export type MuridTahfidzDetailsArgs = {
    /**
     * Select specific fields to fetch from the MuridTahfidzDetails
     * 
    **/
    select?: MuridTahfidzDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MuridTahfidzDetailsInclude | null
  }



  /**
   * Model Parent
   */


  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentAvgAggregateOutputType = {
    id: number | null
    penghasilanPerBulan: number | null
  }

  export type ParentSumAggregateOutputType = {
    id: number | null
    penghasilanPerBulan: number | null
  }

  export type ParentMinAggregateOutputType = {
    id: number | null
    nip: string | null
    nama: string | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    jenisKelamin: JenisKelamin | null
    agama: Agama | null
    pendidikanTerakhir: Pendidikan | null
    penghasilanPerBulan: number | null
    pekerjaan: string | null
    nomorTelepon: string | null
    statusHidup: Hidup | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type ParentMaxAggregateOutputType = {
    id: number | null
    nip: string | null
    nama: string | null
    tempatLahir: string | null
    tanggalLahir: Date | null
    jenisKelamin: JenisKelamin | null
    agama: Agama | null
    pendidikanTerakhir: Pendidikan | null
    penghasilanPerBulan: number | null
    pekerjaan: string | null
    nomorTelepon: string | null
    statusHidup: Hidup | null
    profileUrl: string | null
    deleted: boolean | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    nip: number
    nama: number
    tempatLahir: number
    tanggalLahir: number
    jenisKelamin: number
    agama: number
    pendidikanTerakhir: number
    penghasilanPerBulan: number
    pekerjaan: number
    nomorTelepon: number
    statusHidup: number
    profileUrl: number
    deleted: number
    _all: number
  }


  export type ParentAvgAggregateInputType = {
    id?: true
    penghasilanPerBulan?: true
  }

  export type ParentSumAggregateInputType = {
    id?: true
    penghasilanPerBulan?: true
  }

  export type ParentMinAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    agama?: true
    pendidikanTerakhir?: true
    penghasilanPerBulan?: true
    pekerjaan?: true
    nomorTelepon?: true
    statusHidup?: true
    profileUrl?: true
    deleted?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    agama?: true
    pendidikanTerakhir?: true
    penghasilanPerBulan?: true
    pekerjaan?: true
    nomorTelepon?: true
    statusHidup?: true
    profileUrl?: true
    deleted?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    tempatLahir?: true
    tanggalLahir?: true
    jenisKelamin?: true
    agama?: true
    pendidikanTerakhir?: true
    penghasilanPerBulan?: true
    pekerjaan?: true
    nomorTelepon?: true
    statusHidup?: true
    profileUrl?: true
    deleted?: true
    _all?: true
  }

  export type ParentAggregateArgs = {
    /**
     * Filter which Parent to aggregate.
     * 
    **/
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }


    
    
  export type ParentGroupByArgs = {
    where?: ParentWhereInput
    orderBy?: Enumerable<ParentOrderByWithAggregationInput>
    by: Array<ParentScalarFieldEnum>
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _avg?: ParentAvgAggregateInputType
    _sum?: ParentSumAggregateInputType
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }


  export type ParentGroupByOutputType = {
    id: number
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl: string | null
    deleted: boolean
    _count: ParentCountAggregateOutputType | null
    _avg: ParentAvgAggregateOutputType | null
    _sum: ParentSumAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Promise<
    Array<
      PickArray<ParentGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ParentGroupByOutputType[P]> 
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      > 
    >


  export type ParentSelect = {
    id?: boolean
    nip?: boolean
    nama?: boolean
    tempatLahir?: boolean
    tanggalLahir?: boolean
    jenisKelamin?: boolean
    agama?: boolean
    pendidikanTerakhir?: boolean
    penghasilanPerBulan?: boolean
    pekerjaan?: boolean
    nomorTelepon?: boolean
    statusHidup?: boolean
    profileUrl?: boolean
    deleted?: boolean
    parentDetails?: boolean | ParentDetailsArgs
    daftarAnak?: boolean | MuridFindManyArgs
    _count?: boolean | ParentCountOutputTypeArgs
  }

  export type ParentInclude = {
    parentDetails?: boolean | ParentDetailsArgs
    daftarAnak?: boolean | MuridFindManyArgs
    _count?: boolean | ParentCountOutputTypeArgs
  }

  export type ParentGetPayload<
    S extends boolean | null | undefined | ParentArgs,
    U = keyof S
      > = S extends true
        ? Parent
    : S extends undefined
    ? never
    : S extends ParentArgs | ParentFindManyArgs
    ?'include' extends U
    ? Parent  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'parentDetails'
        ? ParentDetailsGetPayload<S['include'][P]> | null :
        P extends 'daftarAnak'
        ? Array < MuridGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? ParentCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Parent ?Parent [P]
  : 
          P extends 'parentDetails'
        ? ParentDetailsGetPayload<S['select'][P]> | null :
        P extends 'daftarAnak'
        ? Array < MuridGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? ParentCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Parent
  : Parent


  type ParentCountArgs = Merge<
    Omit<ParentFindManyArgs, 'select' | 'include'> & {
      select?: ParentCountAggregateInputType | true
    }
  >

  export interface ParentDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Parent'> extends True ? CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>> : CheckSelect<T, Prisma__ParentClient<Parent | null >, Prisma__ParentClient<ParentGetPayload<T> | null >>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Parent'> extends True ? CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>> : CheckSelect<T, Prisma__ParentClient<Parent | null >, Prisma__ParentClient<ParentGetPayload<T> | null >>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ParentFindManyArgs>(
      args?: SelectSubset<T, ParentFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Parent>>, PrismaPromise<Array<ParentGetPayload<T>>>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
    **/
    create<T extends ParentCreateArgs>(
      args: SelectSubset<T, ParentCreateArgs>
    ): CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>>

    /**
     * Create many Parents.
     *     @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     *     @example
     *     // Create many Parents
     *     const parent = await prisma.parent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParentCreateManyArgs>(
      args?: SelectSubset<T, ParentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
    **/
    delete<T extends ParentDeleteArgs>(
      args: SelectSubset<T, ParentDeleteArgs>
    ): CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParentUpdateArgs>(
      args: SelectSubset<T, ParentUpdateArgs>
    ): CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParentDeleteManyArgs>(
      args?: SelectSubset<T, ParentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParentUpdateManyArgs>(
      args: SelectSubset<T, ParentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
    **/
    upsert<T extends ParentUpsertArgs>(
      args: SelectSubset<T, ParentUpsertArgs>
    ): CheckSelect<T, Prisma__ParentClient<Parent>, Prisma__ParentClient<ParentGetPayload<T>>>

    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParentClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parentDetails<T extends ParentDetailsArgs = {}>(args?: Subset<T, ParentDetailsArgs>): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails | null >, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T> | null >>;

    daftarAnak<T extends MuridFindManyArgs = {}>(args?: Subset<T, MuridFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Murid>>, PrismaPromise<Array<MuridGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * Throw an Error if a Parent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Parent to fetch.
     * 
    **/
    where: ParentWhereUniqueInput
  }


  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * Throw an Error if a Parent can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Parent to fetch.
     * 
    **/
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     * 
    **/
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     * 
    **/
    distinct?: Enumerable<ParentScalarFieldEnum>
  }


  /**
   * Parent findMany
   */
  export type ParentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * Filter, which Parents to fetch.
     * 
    **/
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     * 
    **/
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ParentScalarFieldEnum>
  }


  /**
   * Parent create
   */
  export type ParentCreateArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * The data needed to create a Parent.
     * 
    **/
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }


  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs = {
    data: Enumerable<ParentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Parent update
   */
  export type ParentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * The data needed to update a Parent.
     * 
    **/
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     * 
    **/
    where: ParentWhereUniqueInput
  }


  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs = {
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    where?: ParentWhereInput
  }


  /**
   * Parent upsert
   */
  export type ParentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * The filter to search for the Parent to update in case it exists.
     * 
    **/
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     * 
    **/
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }


  /**
   * Parent delete
   */
  export type ParentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
    /**
     * Filter which Parent to delete.
     * 
    **/
    where: ParentWhereUniqueInput
  }


  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs = {
    where?: ParentWhereInput
  }


  /**
   * Parent without action
   */
  export type ParentArgs = {
    /**
     * Select specific fields to fetch from the Parent
     * 
    **/
    select?: ParentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentInclude | null
  }



  /**
   * Model ParentDetails
   */


  export type AggregateParentDetails = {
    _count: ParentDetailsCountAggregateOutputType | null
    _avg: ParentDetailsAvgAggregateOutputType | null
    _sum: ParentDetailsSumAggregateOutputType | null
    _min: ParentDetailsMinAggregateOutputType | null
    _max: ParentDetailsMaxAggregateOutputType | null
  }

  export type ParentDetailsAvgAggregateOutputType = {
    parentId: number | null
    userId: number | null
  }

  export type ParentDetailsSumAggregateOutputType = {
    parentId: number | null
    userId: number | null
  }

  export type ParentDetailsMinAggregateOutputType = {
    parentId: number | null
    userId: number | null
  }

  export type ParentDetailsMaxAggregateOutputType = {
    parentId: number | null
    userId: number | null
  }

  export type ParentDetailsCountAggregateOutputType = {
    parentId: number
    userId: number
    _all: number
  }


  export type ParentDetailsAvgAggregateInputType = {
    parentId?: true
    userId?: true
  }

  export type ParentDetailsSumAggregateInputType = {
    parentId?: true
    userId?: true
  }

  export type ParentDetailsMinAggregateInputType = {
    parentId?: true
    userId?: true
  }

  export type ParentDetailsMaxAggregateInputType = {
    parentId?: true
    userId?: true
  }

  export type ParentDetailsCountAggregateInputType = {
    parentId?: true
    userId?: true
    _all?: true
  }

  export type ParentDetailsAggregateArgs = {
    /**
     * Filter which ParentDetails to aggregate.
     * 
    **/
    where?: ParentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ParentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParentDetails
    **/
    _count?: true | ParentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParentDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParentDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentDetailsMaxAggregateInputType
  }

  export type GetParentDetailsAggregateType<T extends ParentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateParentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParentDetails[P]>
      : GetScalarType<T[P], AggregateParentDetails[P]>
  }


    
    
  export type ParentDetailsGroupByArgs = {
    where?: ParentDetailsWhereInput
    orderBy?: Enumerable<ParentDetailsOrderByWithAggregationInput>
    by: Array<ParentDetailsScalarFieldEnum>
    having?: ParentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentDetailsCountAggregateInputType | true
    _avg?: ParentDetailsAvgAggregateInputType
    _sum?: ParentDetailsSumAggregateInputType
    _min?: ParentDetailsMinAggregateInputType
    _max?: ParentDetailsMaxAggregateInputType
  }


  export type ParentDetailsGroupByOutputType = {
    parentId: number
    userId: number
    _count: ParentDetailsCountAggregateOutputType | null
    _avg: ParentDetailsAvgAggregateOutputType | null
    _sum: ParentDetailsSumAggregateOutputType | null
    _min: ParentDetailsMinAggregateOutputType | null
    _max: ParentDetailsMaxAggregateOutputType | null
  }

  type GetParentDetailsGroupByPayload<T extends ParentDetailsGroupByArgs> = Promise<
    Array<
      PickArray<ParentDetailsGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof ParentDetailsGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], ParentDetailsGroupByOutputType[P]> 
            : GetScalarType<T[P], ParentDetailsGroupByOutputType[P]>
        }
      > 
    >


  export type ParentDetailsSelect = {
    parentId?: boolean
    parent?: boolean | ParentArgs
    userId?: boolean
    user?: boolean | UserArgs
  }

  export type ParentDetailsInclude = {
    parent?: boolean | ParentArgs
    user?: boolean | UserArgs
  }

  export type ParentDetailsGetPayload<
    S extends boolean | null | undefined | ParentDetailsArgs,
    U = keyof S
      > = S extends true
        ? ParentDetails
    : S extends undefined
    ? never
    : S extends ParentDetailsArgs | ParentDetailsFindManyArgs
    ?'include' extends U
    ? ParentDetails  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'parent'
        ? ParentGetPayload<S['include'][P]> :
        P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ParentDetails ?ParentDetails [P]
  : 
          P extends 'parent'
        ? ParentGetPayload<S['select'][P]> :
        P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : ParentDetails
  : ParentDetails


  type ParentDetailsCountArgs = Merge<
    Omit<ParentDetailsFindManyArgs, 'select' | 'include'> & {
      select?: ParentDetailsCountAggregateInputType | true
    }
  >

  export interface ParentDetailsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ParentDetails that matches the filter.
     * @param {ParentDetailsFindUniqueArgs} args - Arguments to find a ParentDetails
     * @example
     * // Get one ParentDetails
     * const parentDetails = await prisma.parentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ParentDetailsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ParentDetailsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ParentDetails'> extends True ? CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>> : CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails | null >, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T> | null >>

    /**
     * Find the first ParentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsFindFirstArgs} args - Arguments to find a ParentDetails
     * @example
     * // Get one ParentDetails
     * const parentDetails = await prisma.parentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ParentDetailsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ParentDetailsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ParentDetails'> extends True ? CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>> : CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails | null >, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T> | null >>

    /**
     * Find zero or more ParentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParentDetails
     * const parentDetails = await prisma.parentDetails.findMany()
     * 
     * // Get first 10 ParentDetails
     * const parentDetails = await prisma.parentDetails.findMany({ take: 10 })
     * 
     * // Only select the `parentId`
     * const parentDetailsWithParentIdOnly = await prisma.parentDetails.findMany({ select: { parentId: true } })
     * 
    **/
    findMany<T extends ParentDetailsFindManyArgs>(
      args?: SelectSubset<T, ParentDetailsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ParentDetails>>, PrismaPromise<Array<ParentDetailsGetPayload<T>>>>

    /**
     * Create a ParentDetails.
     * @param {ParentDetailsCreateArgs} args - Arguments to create a ParentDetails.
     * @example
     * // Create one ParentDetails
     * const ParentDetails = await prisma.parentDetails.create({
     *   data: {
     *     // ... data to create a ParentDetails
     *   }
     * })
     * 
    **/
    create<T extends ParentDetailsCreateArgs>(
      args: SelectSubset<T, ParentDetailsCreateArgs>
    ): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>>

    /**
     * Create many ParentDetails.
     *     @param {ParentDetailsCreateManyArgs} args - Arguments to create many ParentDetails.
     *     @example
     *     // Create many ParentDetails
     *     const parentDetails = await prisma.parentDetails.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ParentDetailsCreateManyArgs>(
      args?: SelectSubset<T, ParentDetailsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ParentDetails.
     * @param {ParentDetailsDeleteArgs} args - Arguments to delete one ParentDetails.
     * @example
     * // Delete one ParentDetails
     * const ParentDetails = await prisma.parentDetails.delete({
     *   where: {
     *     // ... filter to delete one ParentDetails
     *   }
     * })
     * 
    **/
    delete<T extends ParentDetailsDeleteArgs>(
      args: SelectSubset<T, ParentDetailsDeleteArgs>
    ): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>>

    /**
     * Update one ParentDetails.
     * @param {ParentDetailsUpdateArgs} args - Arguments to update one ParentDetails.
     * @example
     * // Update one ParentDetails
     * const parentDetails = await prisma.parentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ParentDetailsUpdateArgs>(
      args: SelectSubset<T, ParentDetailsUpdateArgs>
    ): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>>

    /**
     * Delete zero or more ParentDetails.
     * @param {ParentDetailsDeleteManyArgs} args - Arguments to filter ParentDetails to delete.
     * @example
     * // Delete a few ParentDetails
     * const { count } = await prisma.parentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ParentDetailsDeleteManyArgs>(
      args?: SelectSubset<T, ParentDetailsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParentDetails
     * const parentDetails = await prisma.parentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ParentDetailsUpdateManyArgs>(
      args: SelectSubset<T, ParentDetailsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ParentDetails.
     * @param {ParentDetailsUpsertArgs} args - Arguments to update or create a ParentDetails.
     * @example
     * // Update or create a ParentDetails
     * const parentDetails = await prisma.parentDetails.upsert({
     *   create: {
     *     // ... data to create a ParentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParentDetails we want to update
     *   }
     * })
    **/
    upsert<T extends ParentDetailsUpsertArgs>(
      args: SelectSubset<T, ParentDetailsUpsertArgs>
    ): CheckSelect<T, Prisma__ParentDetailsClient<ParentDetails>, Prisma__ParentDetailsClient<ParentDetailsGetPayload<T>>>

    /**
     * Count the number of ParentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsCountArgs} args - Arguments to filter ParentDetails to count.
     * @example
     * // Count the number of ParentDetails
     * const count = await prisma.parentDetails.count({
     *   where: {
     *     // ... the filter for the ParentDetails we want to count
     *   }
     * })
    **/
    count<T extends ParentDetailsCountArgs>(
      args?: Subset<T, ParentDetailsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentDetailsAggregateArgs>(args: Subset<T, ParentDetailsAggregateArgs>): PrismaPromise<GetParentDetailsAggregateType<T>>

    /**
     * Group by ParentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: ParentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentDetailsGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ParentDetailsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    parent<T extends ParentArgs = {}>(args?: Subset<T, ParentArgs>): CheckSelect<T, Prisma__ParentClient<Parent | null >, Prisma__ParentClient<ParentGetPayload<T> | null >>;

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ParentDetails findUnique
   */
  export type ParentDetailsFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * Throw an Error if a ParentDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ParentDetails to fetch.
     * 
    **/
    where: ParentDetailsWhereUniqueInput
  }


  /**
   * ParentDetails findFirst
   */
  export type ParentDetailsFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * Throw an Error if a ParentDetails can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ParentDetails to fetch.
     * 
    **/
    where?: ParentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParentDetails.
     * 
    **/
    cursor?: ParentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentDetails.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParentDetails.
     * 
    **/
    distinct?: Enumerable<ParentDetailsScalarFieldEnum>
  }


  /**
   * ParentDetails findMany
   */
  export type ParentDetailsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * Filter, which ParentDetails to fetch.
     * 
    **/
    where?: ParentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParentDetails to fetch.
     * 
    **/
    orderBy?: Enumerable<ParentDetailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParentDetails.
     * 
    **/
    cursor?: ParentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParentDetails from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParentDetails.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ParentDetailsScalarFieldEnum>
  }


  /**
   * ParentDetails create
   */
  export type ParentDetailsCreateArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * The data needed to create a ParentDetails.
     * 
    **/
    data: XOR<ParentDetailsCreateInput, ParentDetailsUncheckedCreateInput>
  }


  /**
   * ParentDetails createMany
   */
  export type ParentDetailsCreateManyArgs = {
    data: Enumerable<ParentDetailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ParentDetails update
   */
  export type ParentDetailsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * The data needed to update a ParentDetails.
     * 
    **/
    data: XOR<ParentDetailsUpdateInput, ParentDetailsUncheckedUpdateInput>
    /**
     * Choose, which ParentDetails to update.
     * 
    **/
    where: ParentDetailsWhereUniqueInput
  }


  /**
   * ParentDetails updateMany
   */
  export type ParentDetailsUpdateManyArgs = {
    data: XOR<ParentDetailsUpdateManyMutationInput, ParentDetailsUncheckedUpdateManyInput>
    where?: ParentDetailsWhereInput
  }


  /**
   * ParentDetails upsert
   */
  export type ParentDetailsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * The filter to search for the ParentDetails to update in case it exists.
     * 
    **/
    where: ParentDetailsWhereUniqueInput
    /**
     * In case the ParentDetails found by the `where` argument doesn't exist, create a new ParentDetails with this data.
     * 
    **/
    create: XOR<ParentDetailsCreateInput, ParentDetailsUncheckedCreateInput>
    /**
     * In case the ParentDetails was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ParentDetailsUpdateInput, ParentDetailsUncheckedUpdateInput>
  }


  /**
   * ParentDetails delete
   */
  export type ParentDetailsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
    /**
     * Filter which ParentDetails to delete.
     * 
    **/
    where: ParentDetailsWhereUniqueInput
  }


  /**
   * ParentDetails deleteMany
   */
  export type ParentDetailsDeleteManyArgs = {
    where?: ParentDetailsWhereInput
  }


  /**
   * ParentDetails without action
   */
  export type ParentDetailsArgs = {
    /**
     * Select specific fields to fetch from the ParentDetails
     * 
    **/
    select?: ParentDetailsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ParentDetailsInclude | null
  }



  /**
   * Model Event
   */


  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
    targetId: number | null
    userId: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
    targetId: number | null
    userId: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    type: TipeEvent | null
    target: EventModelType | null
    targetId: number | null
    userId: number | null
    time: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    type: TipeEvent | null
    target: EventModelType | null
    targetId: number | null
    userId: number | null
    time: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    type: number
    target: number
    targetId: number
    userId: number
    time: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
    targetId?: true
    userId?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
    targetId?: true
    userId?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    type?: true
    target?: true
    targetId?: true
    userId?: true
    time?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    type?: true
    target?: true
    targetId?: true
    userId?: true
    time?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    type?: true
    target?: true
    targetId?: true
    userId?: true
    time?: true
    _all?: true
  }

  export type EventAggregateArgs = {
    /**
     * Filter which Event to aggregate.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }


    
    
  export type EventGroupByArgs = {
    where?: EventWhereInput
    orderBy?: Enumerable<EventOrderByWithAggregationInput>
    by: Array<EventScalarFieldEnum>
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }


  export type EventGroupByOutputType = {
    id: number
    type: TipeEvent
    target: EventModelType
    targetId: number
    userId: number
    time: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Promise<
    Array<
      PickArray<EventGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], EventGroupByOutputType[P]> 
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      > 
    >


  export type EventSelect = {
    id?: boolean
    type?: boolean
    target?: boolean
    targetId?: boolean
    actor?: boolean | UserArgs
    userId?: boolean
    time?: boolean
  }

  export type EventInclude = {
    actor?: boolean | UserArgs
  }

  export type EventGetPayload<
    S extends boolean | null | undefined | EventArgs,
    U = keyof S
      > = S extends true
        ? Event
    : S extends undefined
    ? never
    : S extends EventArgs | EventFindManyArgs
    ?'include' extends U
    ? Event  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'actor'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Event ?Event [P]
  : 
          P extends 'actor'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Event
  : Event


  type EventCountArgs = Merge<
    Omit<EventFindManyArgs, 'select' | 'include'> & {
      select?: EventCountAggregateInputType | true
    }
  >

  export interface EventDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EventFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EventFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EventFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EventFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Event'> extends True ? CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>> : CheckSelect<T, Prisma__EventClient<Event | null >, Prisma__EventClient<EventGetPayload<T> | null >>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EventFindManyArgs>(
      args?: SelectSubset<T, EventFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Event>>, PrismaPromise<Array<EventGetPayload<T>>>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
    **/
    create<T extends EventCreateArgs>(
      args: SelectSubset<T, EventCreateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Create many Events.
     *     @param {EventCreateManyArgs} args - Arguments to create many Events.
     *     @example
     *     // Create many Events
     *     const event = await prisma.event.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EventCreateManyArgs>(
      args?: SelectSubset<T, EventCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
    **/
    delete<T extends EventDeleteArgs>(
      args: SelectSubset<T, EventDeleteArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EventUpdateArgs>(
      args: SelectSubset<T, EventUpdateArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EventDeleteManyArgs>(
      args?: SelectSubset<T, EventDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EventUpdateManyArgs>(
      args: SelectSubset<T, EventUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
    **/
    upsert<T extends EventUpsertArgs>(
      args: SelectSubset<T, EventUpsertArgs>
    ): CheckSelect<T, Prisma__EventClient<Event>, Prisma__EventClient<EventGetPayload<T>>>

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EventClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    actor<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event findFirst
   */
  export type EventFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Throw an Error if a Event can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Event to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     * 
    **/
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event findMany
   */
  export type EventFindManyArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter, which Events to fetch.
     * 
    **/
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     * 
    **/
    orderBy?: Enumerable<EventOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     * 
    **/
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EventScalarFieldEnum>
  }


  /**
   * Event create
   */
  export type EventCreateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to create a Event.
     * 
    **/
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }


  /**
   * Event createMany
   */
  export type EventCreateManyArgs = {
    data: Enumerable<EventCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Event update
   */
  export type EventUpdateArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The data needed to update a Event.
     * 
    **/
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs = {
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    where?: EventWhereInput
  }


  /**
   * Event upsert
   */
  export type EventUpsertArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * The filter to search for the Event to update in case it exists.
     * 
    **/
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     * 
    **/
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }


  /**
   * Event delete
   */
  export type EventDeleteArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
    /**
     * Filter which Event to delete.
     * 
    **/
    where: EventWhereUniqueInput
  }


  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs = {
    where?: EventWhereInput
  }


  /**
   * Event without action
   */
  export type EventArgs = {
    /**
     * Select specific fields to fetch from the Event
     * 
    **/
    select?: EventSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EventInclude | null
  }



  /**
   * Model Halaqoh
   */


  export type AggregateHalaqoh = {
    _count: HalaqohCountAggregateOutputType | null
    _avg: HalaqohAvgAggregateOutputType | null
    _sum: HalaqohSumAggregateOutputType | null
    _min: HalaqohMinAggregateOutputType | null
    _max: HalaqohMaxAggregateOutputType | null
  }

  export type HalaqohAvgAggregateOutputType = {
    id: number | null
    guruId: number | null
  }

  export type HalaqohSumAggregateOutputType = {
    id: number | null
    guruId: number | null
  }

  export type HalaqohMinAggregateOutputType = {
    id: number | null
    kode: string | null
    guruId: number | null
  }

  export type HalaqohMaxAggregateOutputType = {
    id: number | null
    kode: string | null
    guruId: number | null
  }

  export type HalaqohCountAggregateOutputType = {
    id: number
    kode: number
    guruId: number
    _all: number
  }


  export type HalaqohAvgAggregateInputType = {
    id?: true
    guruId?: true
  }

  export type HalaqohSumAggregateInputType = {
    id?: true
    guruId?: true
  }

  export type HalaqohMinAggregateInputType = {
    id?: true
    kode?: true
    guruId?: true
  }

  export type HalaqohMaxAggregateInputType = {
    id?: true
    kode?: true
    guruId?: true
  }

  export type HalaqohCountAggregateInputType = {
    id?: true
    kode?: true
    guruId?: true
    _all?: true
  }

  export type HalaqohAggregateArgs = {
    /**
     * Filter which Halaqoh to aggregate.
     * 
    **/
    where?: HalaqohWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Halaqohs to fetch.
     * 
    **/
    orderBy?: Enumerable<HalaqohOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: HalaqohWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Halaqohs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Halaqohs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Halaqohs
    **/
    _count?: true | HalaqohCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HalaqohAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HalaqohSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HalaqohMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HalaqohMaxAggregateInputType
  }

  export type GetHalaqohAggregateType<T extends HalaqohAggregateArgs> = {
        [P in keyof T & keyof AggregateHalaqoh]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHalaqoh[P]>
      : GetScalarType<T[P], AggregateHalaqoh[P]>
  }


    
    
  export type HalaqohGroupByArgs = {
    where?: HalaqohWhereInput
    orderBy?: Enumerable<HalaqohOrderByWithAggregationInput>
    by: Array<HalaqohScalarFieldEnum>
    having?: HalaqohScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HalaqohCountAggregateInputType | true
    _avg?: HalaqohAvgAggregateInputType
    _sum?: HalaqohSumAggregateInputType
    _min?: HalaqohMinAggregateInputType
    _max?: HalaqohMaxAggregateInputType
  }


  export type HalaqohGroupByOutputType = {
    id: number
    kode: string
    guruId: number
    _count: HalaqohCountAggregateOutputType | null
    _avg: HalaqohAvgAggregateOutputType | null
    _sum: HalaqohSumAggregateOutputType | null
    _min: HalaqohMinAggregateOutputType | null
    _max: HalaqohMaxAggregateOutputType | null
  }

  type GetHalaqohGroupByPayload<T extends HalaqohGroupByArgs> = Promise<
    Array<
      PickArray<HalaqohGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof HalaqohGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], HalaqohGroupByOutputType[P]> 
            : GetScalarType<T[P], HalaqohGroupByOutputType[P]>
        }
      > 
    >


  export type HalaqohSelect = {
    id?: boolean
    kode?: boolean
    guruId?: boolean
    guruTahfidzDetail?: boolean | GuruTahfidzDetailsArgs
    muridTahfidzDetail?: boolean | MuridTahfidzDetailsFindManyArgs
    _count?: boolean | HalaqohCountOutputTypeArgs
  }

  export type HalaqohInclude = {
    guruTahfidzDetail?: boolean | GuruTahfidzDetailsArgs
    muridTahfidzDetail?: boolean | MuridTahfidzDetailsFindManyArgs
    _count?: boolean | HalaqohCountOutputTypeArgs
  }

  export type HalaqohGetPayload<
    S extends boolean | null | undefined | HalaqohArgs,
    U = keyof S
      > = S extends true
        ? Halaqoh
    : S extends undefined
    ? never
    : S extends HalaqohArgs | HalaqohFindManyArgs
    ?'include' extends U
    ? Halaqoh  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'guruTahfidzDetail'
        ? GuruTahfidzDetailsGetPayload<S['include'][P]> :
        P extends 'muridTahfidzDetail'
        ? Array < MuridTahfidzDetailsGetPayload<S['include'][P]>>  :
        P extends '_count'
        ? HalaqohCountOutputTypeGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Halaqoh ?Halaqoh [P]
  : 
          P extends 'guruTahfidzDetail'
        ? GuruTahfidzDetailsGetPayload<S['select'][P]> :
        P extends 'muridTahfidzDetail'
        ? Array < MuridTahfidzDetailsGetPayload<S['select'][P]>>  :
        P extends '_count'
        ? HalaqohCountOutputTypeGetPayload<S['select'][P]> | null : never
  } 
    : Halaqoh
  : Halaqoh


  type HalaqohCountArgs = Merge<
    Omit<HalaqohFindManyArgs, 'select' | 'include'> & {
      select?: HalaqohCountAggregateInputType | true
    }
  >

  export interface HalaqohDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Halaqoh that matches the filter.
     * @param {HalaqohFindUniqueArgs} args - Arguments to find a Halaqoh
     * @example
     * // Get one Halaqoh
     * const halaqoh = await prisma.halaqoh.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HalaqohFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HalaqohFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Halaqoh'> extends True ? CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>> : CheckSelect<T, Prisma__HalaqohClient<Halaqoh | null >, Prisma__HalaqohClient<HalaqohGetPayload<T> | null >>

    /**
     * Find the first Halaqoh that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohFindFirstArgs} args - Arguments to find a Halaqoh
     * @example
     * // Get one Halaqoh
     * const halaqoh = await prisma.halaqoh.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HalaqohFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HalaqohFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Halaqoh'> extends True ? CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>> : CheckSelect<T, Prisma__HalaqohClient<Halaqoh | null >, Prisma__HalaqohClient<HalaqohGetPayload<T> | null >>

    /**
     * Find zero or more Halaqohs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Halaqohs
     * const halaqohs = await prisma.halaqoh.findMany()
     * 
     * // Get first 10 Halaqohs
     * const halaqohs = await prisma.halaqoh.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const halaqohWithIdOnly = await prisma.halaqoh.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HalaqohFindManyArgs>(
      args?: SelectSubset<T, HalaqohFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Halaqoh>>, PrismaPromise<Array<HalaqohGetPayload<T>>>>

    /**
     * Create a Halaqoh.
     * @param {HalaqohCreateArgs} args - Arguments to create a Halaqoh.
     * @example
     * // Create one Halaqoh
     * const Halaqoh = await prisma.halaqoh.create({
     *   data: {
     *     // ... data to create a Halaqoh
     *   }
     * })
     * 
    **/
    create<T extends HalaqohCreateArgs>(
      args: SelectSubset<T, HalaqohCreateArgs>
    ): CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>>

    /**
     * Create many Halaqohs.
     *     @param {HalaqohCreateManyArgs} args - Arguments to create many Halaqohs.
     *     @example
     *     // Create many Halaqohs
     *     const halaqoh = await prisma.halaqoh.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HalaqohCreateManyArgs>(
      args?: SelectSubset<T, HalaqohCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Halaqoh.
     * @param {HalaqohDeleteArgs} args - Arguments to delete one Halaqoh.
     * @example
     * // Delete one Halaqoh
     * const Halaqoh = await prisma.halaqoh.delete({
     *   where: {
     *     // ... filter to delete one Halaqoh
     *   }
     * })
     * 
    **/
    delete<T extends HalaqohDeleteArgs>(
      args: SelectSubset<T, HalaqohDeleteArgs>
    ): CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>>

    /**
     * Update one Halaqoh.
     * @param {HalaqohUpdateArgs} args - Arguments to update one Halaqoh.
     * @example
     * // Update one Halaqoh
     * const halaqoh = await prisma.halaqoh.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HalaqohUpdateArgs>(
      args: SelectSubset<T, HalaqohUpdateArgs>
    ): CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>>

    /**
     * Delete zero or more Halaqohs.
     * @param {HalaqohDeleteManyArgs} args - Arguments to filter Halaqohs to delete.
     * @example
     * // Delete a few Halaqohs
     * const { count } = await prisma.halaqoh.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HalaqohDeleteManyArgs>(
      args?: SelectSubset<T, HalaqohDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Halaqohs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Halaqohs
     * const halaqoh = await prisma.halaqoh.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HalaqohUpdateManyArgs>(
      args: SelectSubset<T, HalaqohUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Halaqoh.
     * @param {HalaqohUpsertArgs} args - Arguments to update or create a Halaqoh.
     * @example
     * // Update or create a Halaqoh
     * const halaqoh = await prisma.halaqoh.upsert({
     *   create: {
     *     // ... data to create a Halaqoh
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Halaqoh we want to update
     *   }
     * })
    **/
    upsert<T extends HalaqohUpsertArgs>(
      args: SelectSubset<T, HalaqohUpsertArgs>
    ): CheckSelect<T, Prisma__HalaqohClient<Halaqoh>, Prisma__HalaqohClient<HalaqohGetPayload<T>>>

    /**
     * Count the number of Halaqohs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohCountArgs} args - Arguments to filter Halaqohs to count.
     * @example
     * // Count the number of Halaqohs
     * const count = await prisma.halaqoh.count({
     *   where: {
     *     // ... the filter for the Halaqohs we want to count
     *   }
     * })
    **/
    count<T extends HalaqohCountArgs>(
      args?: Subset<T, HalaqohCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HalaqohCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Halaqoh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HalaqohAggregateArgs>(args: Subset<T, HalaqohAggregateArgs>): PrismaPromise<GetHalaqohAggregateType<T>>

    /**
     * Group by Halaqoh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HalaqohGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HalaqohGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HalaqohGroupByArgs['orderBy'] }
        : { orderBy?: HalaqohGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HalaqohGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHalaqohGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Halaqoh.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HalaqohClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    guruTahfidzDetail<T extends GuruTahfidzDetailsArgs = {}>(args?: Subset<T, GuruTahfidzDetailsArgs>): CheckSelect<T, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetails | null >, Prisma__GuruTahfidzDetailsClient<GuruTahfidzDetailsGetPayload<T> | null >>;

    muridTahfidzDetail<T extends MuridTahfidzDetailsFindManyArgs = {}>(args?: Subset<T, MuridTahfidzDetailsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MuridTahfidzDetails>>, PrismaPromise<Array<MuridTahfidzDetailsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Halaqoh findUnique
   */
  export type HalaqohFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * Throw an Error if a Halaqoh can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Halaqoh to fetch.
     * 
    **/
    where: HalaqohWhereUniqueInput
  }


  /**
   * Halaqoh findFirst
   */
  export type HalaqohFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * Throw an Error if a Halaqoh can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Halaqoh to fetch.
     * 
    **/
    where?: HalaqohWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Halaqohs to fetch.
     * 
    **/
    orderBy?: Enumerable<HalaqohOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Halaqohs.
     * 
    **/
    cursor?: HalaqohWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Halaqohs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Halaqohs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Halaqohs.
     * 
    **/
    distinct?: Enumerable<HalaqohScalarFieldEnum>
  }


  /**
   * Halaqoh findMany
   */
  export type HalaqohFindManyArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * Filter, which Halaqohs to fetch.
     * 
    **/
    where?: HalaqohWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Halaqohs to fetch.
     * 
    **/
    orderBy?: Enumerable<HalaqohOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Halaqohs.
     * 
    **/
    cursor?: HalaqohWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Halaqohs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Halaqohs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<HalaqohScalarFieldEnum>
  }


  /**
   * Halaqoh create
   */
  export type HalaqohCreateArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * The data needed to create a Halaqoh.
     * 
    **/
    data: XOR<HalaqohCreateInput, HalaqohUncheckedCreateInput>
  }


  /**
   * Halaqoh createMany
   */
  export type HalaqohCreateManyArgs = {
    data: Enumerable<HalaqohCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Halaqoh update
   */
  export type HalaqohUpdateArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * The data needed to update a Halaqoh.
     * 
    **/
    data: XOR<HalaqohUpdateInput, HalaqohUncheckedUpdateInput>
    /**
     * Choose, which Halaqoh to update.
     * 
    **/
    where: HalaqohWhereUniqueInput
  }


  /**
   * Halaqoh updateMany
   */
  export type HalaqohUpdateManyArgs = {
    data: XOR<HalaqohUpdateManyMutationInput, HalaqohUncheckedUpdateManyInput>
    where?: HalaqohWhereInput
  }


  /**
   * Halaqoh upsert
   */
  export type HalaqohUpsertArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * The filter to search for the Halaqoh to update in case it exists.
     * 
    **/
    where: HalaqohWhereUniqueInput
    /**
     * In case the Halaqoh found by the `where` argument doesn't exist, create a new Halaqoh with this data.
     * 
    **/
    create: XOR<HalaqohCreateInput, HalaqohUncheckedCreateInput>
    /**
     * In case the Halaqoh was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<HalaqohUpdateInput, HalaqohUncheckedUpdateInput>
  }


  /**
   * Halaqoh delete
   */
  export type HalaqohDeleteArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
    /**
     * Filter which Halaqoh to delete.
     * 
    **/
    where: HalaqohWhereUniqueInput
  }


  /**
   * Halaqoh deleteMany
   */
  export type HalaqohDeleteManyArgs = {
    where?: HalaqohWhereInput
  }


  /**
   * Halaqoh without action
   */
  export type HalaqohArgs = {
    /**
     * Select specific fields to fetch from the Halaqoh
     * 
    **/
    select?: HalaqohSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: HalaqohInclude | null
  }



  /**
   * Model Session
   */


  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    juz: number | null
    halaman: number | null
    nilaiTajwid: number | null
    nilaiKelancaran: number | null
    nilaiMakhroj: number | null
    nilaiSifatHuruf: number | null
    muridId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    juz: number | null
    halaman: number | null
    nilaiTajwid: number | null
    nilaiKelancaran: number | null
    nilaiMakhroj: number | null
    nilaiSifatHuruf: number | null
    muridId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    type: TipeSesi | null
    waktu: Date | null
    juz: number | null
    halaman: number | null
    awalSetoran: string | null
    akhirSetoran: string | null
    nilaiTajwid: number | null
    nilaiKelancaran: number | null
    nilaiMakhroj: number | null
    nilaiSifatHuruf: number | null
    jamTahfidz: string | null
    muridId: number | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    type: TipeSesi | null
    waktu: Date | null
    juz: number | null
    halaman: number | null
    awalSetoran: string | null
    akhirSetoran: string | null
    nilaiTajwid: number | null
    nilaiKelancaran: number | null
    nilaiMakhroj: number | null
    nilaiSifatHuruf: number | null
    jamTahfidz: string | null
    muridId: number | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    type: number
    waktu: number
    juz: number
    halaman: number
    awalSetoran: number
    akhirSetoran: number
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: number
    muridId: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    juz?: true
    halaman?: true
    nilaiTajwid?: true
    nilaiKelancaran?: true
    nilaiMakhroj?: true
    nilaiSifatHuruf?: true
    muridId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    juz?: true
    halaman?: true
    nilaiTajwid?: true
    nilaiKelancaran?: true
    nilaiMakhroj?: true
    nilaiSifatHuruf?: true
    muridId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    type?: true
    waktu?: true
    juz?: true
    halaman?: true
    awalSetoran?: true
    akhirSetoran?: true
    nilaiTajwid?: true
    nilaiKelancaran?: true
    nilaiMakhroj?: true
    nilaiSifatHuruf?: true
    jamTahfidz?: true
    muridId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    type?: true
    waktu?: true
    juz?: true
    halaman?: true
    awalSetoran?: true
    akhirSetoran?: true
    nilaiTajwid?: true
    nilaiKelancaran?: true
    nilaiMakhroj?: true
    nilaiSifatHuruf?: true
    jamTahfidz?: true
    muridId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    type?: true
    waktu?: true
    juz?: true
    halaman?: true
    awalSetoran?: true
    akhirSetoran?: true
    nilaiTajwid?: true
    nilaiKelancaran?: true
    nilaiMakhroj?: true
    nilaiSifatHuruf?: true
    jamTahfidz?: true
    muridId?: true
    _all?: true
  }

  export type SessionAggregateArgs = {
    /**
     * Filter which Session to aggregate.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }


    
    
  export type SessionGroupByArgs = {
    where?: SessionWhereInput
    orderBy?: Enumerable<SessionOrderByWithAggregationInput>
    by: Array<SessionScalarFieldEnum>
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }


  export type SessionGroupByOutputType = {
    id: number
    type: TipeSesi
    waktu: Date
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
    muridId: number
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Promise<
    Array<
      PickArray<SessionGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], SessionGroupByOutputType[P]> 
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      > 
    >


  export type SessionSelect = {
    id?: boolean
    type?: boolean
    waktu?: boolean
    juz?: boolean
    halaman?: boolean
    awalSetoran?: boolean
    akhirSetoran?: boolean
    nilaiTajwid?: boolean
    nilaiKelancaran?: boolean
    nilaiMakhroj?: boolean
    nilaiSifatHuruf?: boolean
    jamTahfidz?: boolean
    muridId?: boolean
    muridTahfidzDetail?: boolean | MuridTahfidzDetailsArgs
  }

  export type SessionInclude = {
    muridTahfidzDetail?: boolean | MuridTahfidzDetailsArgs
  }

  export type SessionGetPayload<
    S extends boolean | null | undefined | SessionArgs,
    U = keyof S
      > = S extends true
        ? Session
    : S extends undefined
    ? never
    : S extends SessionArgs | SessionFindManyArgs
    ?'include' extends U
    ? Session  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'muridTahfidzDetail'
        ? MuridTahfidzDetailsGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Session ?Session [P]
  : 
          P extends 'muridTahfidzDetail'
        ? MuridTahfidzDetailsGetPayload<S['select'][P]> : never
  } 
    : Session
  : Session


  type SessionCountArgs = Merge<
    Omit<SessionFindManyArgs, 'select' | 'include'> & {
      select?: SessionCountAggregateInputType | true
    }
  >

  export interface SessionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Session'> extends True ? CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>> : CheckSelect<T, Prisma__SessionClient<Session | null >, Prisma__SessionClient<SessionGetPayload<T> | null >>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Session>>, PrismaPromise<Array<SessionGetPayload<T>>>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs>
    ): CheckSelect<T, Prisma__SessionClient<Session>, Prisma__SessionClient<SessionGetPayload<T>>>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SessionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    muridTahfidzDetail<T extends MuridTahfidzDetailsArgs = {}>(args?: Subset<T, MuridTahfidzDetailsArgs>): CheckSelect<T, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetails | null >, Prisma__MuridTahfidzDetailsClient<MuridTahfidzDetailsGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Throw an Error if a Session can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Session to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     * 
    **/
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter, which Sessions to fetch.
     * 
    **/
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     * 
    **/
    orderBy?: Enumerable<SessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     * 
    **/
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SessionScalarFieldEnum>
  }


  /**
   * Session create
   */
  export type SessionCreateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to create a Session.
     * 
    **/
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs = {
    data: Enumerable<SessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The data needed to update a Session.
     * 
    **/
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs = {
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * The filter to search for the Session to update in case it exists.
     * 
    **/
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     * 
    **/
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
    /**
     * Filter which Session to delete.
     * 
    **/
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs = {
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionArgs = {
    /**
     * Select specific fields to fetch from the Session
     * 
    **/
    select?: SessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SessionInclude | null
  }



  /**
   * Model JamTahfidz
   */


  export type AggregateJamTahfidz = {
    _count: JamTahfidzCountAggregateOutputType | null
    _avg: JamTahfidzAvgAggregateOutputType | null
    _sum: JamTahfidzSumAggregateOutputType | null
    _min: JamTahfidzMinAggregateOutputType | null
    _max: JamTahfidzMaxAggregateOutputType | null
  }

  export type JamTahfidzAvgAggregateOutputType = {
    id: number | null
  }

  export type JamTahfidzSumAggregateOutputType = {
    id: number | null
  }

  export type JamTahfidzMinAggregateOutputType = {
    id: number | null
    waktuMulai: Date | null
    waktuSelesai: Date | null
    namaJam: string | null
    tipe: TipeSesi | null
  }

  export type JamTahfidzMaxAggregateOutputType = {
    id: number | null
    waktuMulai: Date | null
    waktuSelesai: Date | null
    namaJam: string | null
    tipe: TipeSesi | null
  }

  export type JamTahfidzCountAggregateOutputType = {
    id: number
    waktuMulai: number
    waktuSelesai: number
    namaJam: number
    tipe: number
    _all: number
  }


  export type JamTahfidzAvgAggregateInputType = {
    id?: true
  }

  export type JamTahfidzSumAggregateInputType = {
    id?: true
  }

  export type JamTahfidzMinAggregateInputType = {
    id?: true
    waktuMulai?: true
    waktuSelesai?: true
    namaJam?: true
    tipe?: true
  }

  export type JamTahfidzMaxAggregateInputType = {
    id?: true
    waktuMulai?: true
    waktuSelesai?: true
    namaJam?: true
    tipe?: true
  }

  export type JamTahfidzCountAggregateInputType = {
    id?: true
    waktuMulai?: true
    waktuSelesai?: true
    namaJam?: true
    tipe?: true
    _all?: true
  }

  export type JamTahfidzAggregateArgs = {
    /**
     * Filter which JamTahfidz to aggregate.
     * 
    **/
    where?: JamTahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JamTahfidzs to fetch.
     * 
    **/
    orderBy?: Enumerable<JamTahfidzOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: JamTahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JamTahfidzs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JamTahfidzs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JamTahfidzs
    **/
    _count?: true | JamTahfidzCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JamTahfidzAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JamTahfidzSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JamTahfidzMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JamTahfidzMaxAggregateInputType
  }

  export type GetJamTahfidzAggregateType<T extends JamTahfidzAggregateArgs> = {
        [P in keyof T & keyof AggregateJamTahfidz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJamTahfidz[P]>
      : GetScalarType<T[P], AggregateJamTahfidz[P]>
  }


    
    
  export type JamTahfidzGroupByArgs = {
    where?: JamTahfidzWhereInput
    orderBy?: Enumerable<JamTahfidzOrderByWithAggregationInput>
    by: Array<JamTahfidzScalarFieldEnum>
    having?: JamTahfidzScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JamTahfidzCountAggregateInputType | true
    _avg?: JamTahfidzAvgAggregateInputType
    _sum?: JamTahfidzSumAggregateInputType
    _min?: JamTahfidzMinAggregateInputType
    _max?: JamTahfidzMaxAggregateInputType
  }


  export type JamTahfidzGroupByOutputType = {
    id: number
    waktuMulai: Date
    waktuSelesai: Date
    namaJam: string
    tipe: TipeSesi
    _count: JamTahfidzCountAggregateOutputType | null
    _avg: JamTahfidzAvgAggregateOutputType | null
    _sum: JamTahfidzSumAggregateOutputType | null
    _min: JamTahfidzMinAggregateOutputType | null
    _max: JamTahfidzMaxAggregateOutputType | null
  }

  type GetJamTahfidzGroupByPayload<T extends JamTahfidzGroupByArgs> = Promise<
    Array<
      PickArray<JamTahfidzGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof JamTahfidzGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], JamTahfidzGroupByOutputType[P]> 
            : GetScalarType<T[P], JamTahfidzGroupByOutputType[P]>
        }
      > 
    >


  export type JamTahfidzSelect = {
    id?: boolean
    waktuMulai?: boolean
    waktuSelesai?: boolean
    namaJam?: boolean
    tipe?: boolean
  }

  export type JamTahfidzGetPayload<
    S extends boolean | null | undefined | JamTahfidzArgs,
    U = keyof S
      > = S extends true
        ? JamTahfidz
    : S extends undefined
    ? never
    : S extends JamTahfidzArgs | JamTahfidzFindManyArgs
    ?'include' extends U
    ? JamTahfidz 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof JamTahfidz ?JamTahfidz [P]
  : 
     never
  } 
    : JamTahfidz
  : JamTahfidz


  type JamTahfidzCountArgs = Merge<
    Omit<JamTahfidzFindManyArgs, 'select' | 'include'> & {
      select?: JamTahfidzCountAggregateInputType | true
    }
  >

  export interface JamTahfidzDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one JamTahfidz that matches the filter.
     * @param {JamTahfidzFindUniqueArgs} args - Arguments to find a JamTahfidz
     * @example
     * // Get one JamTahfidz
     * const jamTahfidz = await prisma.jamTahfidz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends JamTahfidzFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, JamTahfidzFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'JamTahfidz'> extends True ? CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>> : CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz | null >, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T> | null >>

    /**
     * Find the first JamTahfidz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzFindFirstArgs} args - Arguments to find a JamTahfidz
     * @example
     * // Get one JamTahfidz
     * const jamTahfidz = await prisma.jamTahfidz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends JamTahfidzFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, JamTahfidzFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'JamTahfidz'> extends True ? CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>> : CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz | null >, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T> | null >>

    /**
     * Find zero or more JamTahfidzs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JamTahfidzs
     * const jamTahfidzs = await prisma.jamTahfidz.findMany()
     * 
     * // Get first 10 JamTahfidzs
     * const jamTahfidzs = await prisma.jamTahfidz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jamTahfidzWithIdOnly = await prisma.jamTahfidz.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends JamTahfidzFindManyArgs>(
      args?: SelectSubset<T, JamTahfidzFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<JamTahfidz>>, PrismaPromise<Array<JamTahfidzGetPayload<T>>>>

    /**
     * Create a JamTahfidz.
     * @param {JamTahfidzCreateArgs} args - Arguments to create a JamTahfidz.
     * @example
     * // Create one JamTahfidz
     * const JamTahfidz = await prisma.jamTahfidz.create({
     *   data: {
     *     // ... data to create a JamTahfidz
     *   }
     * })
     * 
    **/
    create<T extends JamTahfidzCreateArgs>(
      args: SelectSubset<T, JamTahfidzCreateArgs>
    ): CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>>

    /**
     * Create many JamTahfidzs.
     *     @param {JamTahfidzCreateManyArgs} args - Arguments to create many JamTahfidzs.
     *     @example
     *     // Create many JamTahfidzs
     *     const jamTahfidz = await prisma.jamTahfidz.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends JamTahfidzCreateManyArgs>(
      args?: SelectSubset<T, JamTahfidzCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a JamTahfidz.
     * @param {JamTahfidzDeleteArgs} args - Arguments to delete one JamTahfidz.
     * @example
     * // Delete one JamTahfidz
     * const JamTahfidz = await prisma.jamTahfidz.delete({
     *   where: {
     *     // ... filter to delete one JamTahfidz
     *   }
     * })
     * 
    **/
    delete<T extends JamTahfidzDeleteArgs>(
      args: SelectSubset<T, JamTahfidzDeleteArgs>
    ): CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>>

    /**
     * Update one JamTahfidz.
     * @param {JamTahfidzUpdateArgs} args - Arguments to update one JamTahfidz.
     * @example
     * // Update one JamTahfidz
     * const jamTahfidz = await prisma.jamTahfidz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends JamTahfidzUpdateArgs>(
      args: SelectSubset<T, JamTahfidzUpdateArgs>
    ): CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>>

    /**
     * Delete zero or more JamTahfidzs.
     * @param {JamTahfidzDeleteManyArgs} args - Arguments to filter JamTahfidzs to delete.
     * @example
     * // Delete a few JamTahfidzs
     * const { count } = await prisma.jamTahfidz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends JamTahfidzDeleteManyArgs>(
      args?: SelectSubset<T, JamTahfidzDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more JamTahfidzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JamTahfidzs
     * const jamTahfidz = await prisma.jamTahfidz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends JamTahfidzUpdateManyArgs>(
      args: SelectSubset<T, JamTahfidzUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one JamTahfidz.
     * @param {JamTahfidzUpsertArgs} args - Arguments to update or create a JamTahfidz.
     * @example
     * // Update or create a JamTahfidz
     * const jamTahfidz = await prisma.jamTahfidz.upsert({
     *   create: {
     *     // ... data to create a JamTahfidz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JamTahfidz we want to update
     *   }
     * })
    **/
    upsert<T extends JamTahfidzUpsertArgs>(
      args: SelectSubset<T, JamTahfidzUpsertArgs>
    ): CheckSelect<T, Prisma__JamTahfidzClient<JamTahfidz>, Prisma__JamTahfidzClient<JamTahfidzGetPayload<T>>>

    /**
     * Count the number of JamTahfidzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzCountArgs} args - Arguments to filter JamTahfidzs to count.
     * @example
     * // Count the number of JamTahfidzs
     * const count = await prisma.jamTahfidz.count({
     *   where: {
     *     // ... the filter for the JamTahfidzs we want to count
     *   }
     * })
    **/
    count<T extends JamTahfidzCountArgs>(
      args?: Subset<T, JamTahfidzCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JamTahfidzCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JamTahfidz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JamTahfidzAggregateArgs>(args: Subset<T, JamTahfidzAggregateArgs>): PrismaPromise<GetJamTahfidzAggregateType<T>>

    /**
     * Group by JamTahfidz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JamTahfidzGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JamTahfidzGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JamTahfidzGroupByArgs['orderBy'] }
        : { orderBy?: JamTahfidzGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JamTahfidzGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJamTahfidzGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for JamTahfidz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__JamTahfidzClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * JamTahfidz findUnique
   */
  export type JamTahfidzFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * Throw an Error if a JamTahfidz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which JamTahfidz to fetch.
     * 
    **/
    where: JamTahfidzWhereUniqueInput
  }


  /**
   * JamTahfidz findFirst
   */
  export type JamTahfidzFindFirstArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * Throw an Error if a JamTahfidz can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which JamTahfidz to fetch.
     * 
    **/
    where?: JamTahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JamTahfidzs to fetch.
     * 
    **/
    orderBy?: Enumerable<JamTahfidzOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JamTahfidzs.
     * 
    **/
    cursor?: JamTahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JamTahfidzs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JamTahfidzs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JamTahfidzs.
     * 
    **/
    distinct?: Enumerable<JamTahfidzScalarFieldEnum>
  }


  /**
   * JamTahfidz findMany
   */
  export type JamTahfidzFindManyArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * Filter, which JamTahfidzs to fetch.
     * 
    **/
    where?: JamTahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JamTahfidzs to fetch.
     * 
    **/
    orderBy?: Enumerable<JamTahfidzOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JamTahfidzs.
     * 
    **/
    cursor?: JamTahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JamTahfidzs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JamTahfidzs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<JamTahfidzScalarFieldEnum>
  }


  /**
   * JamTahfidz create
   */
  export type JamTahfidzCreateArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * The data needed to create a JamTahfidz.
     * 
    **/
    data: XOR<JamTahfidzCreateInput, JamTahfidzUncheckedCreateInput>
  }


  /**
   * JamTahfidz createMany
   */
  export type JamTahfidzCreateManyArgs = {
    data: Enumerable<JamTahfidzCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * JamTahfidz update
   */
  export type JamTahfidzUpdateArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * The data needed to update a JamTahfidz.
     * 
    **/
    data: XOR<JamTahfidzUpdateInput, JamTahfidzUncheckedUpdateInput>
    /**
     * Choose, which JamTahfidz to update.
     * 
    **/
    where: JamTahfidzWhereUniqueInput
  }


  /**
   * JamTahfidz updateMany
   */
  export type JamTahfidzUpdateManyArgs = {
    data: XOR<JamTahfidzUpdateManyMutationInput, JamTahfidzUncheckedUpdateManyInput>
    where?: JamTahfidzWhereInput
  }


  /**
   * JamTahfidz upsert
   */
  export type JamTahfidzUpsertArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * The filter to search for the JamTahfidz to update in case it exists.
     * 
    **/
    where: JamTahfidzWhereUniqueInput
    /**
     * In case the JamTahfidz found by the `where` argument doesn't exist, create a new JamTahfidz with this data.
     * 
    **/
    create: XOR<JamTahfidzCreateInput, JamTahfidzUncheckedCreateInput>
    /**
     * In case the JamTahfidz was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<JamTahfidzUpdateInput, JamTahfidzUncheckedUpdateInput>
  }


  /**
   * JamTahfidz delete
   */
  export type JamTahfidzDeleteArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
    /**
     * Filter which JamTahfidz to delete.
     * 
    **/
    where: JamTahfidzWhereUniqueInput
  }


  /**
   * JamTahfidz deleteMany
   */
  export type JamTahfidzDeleteManyArgs = {
    where?: JamTahfidzWhereInput
  }


  /**
   * JamTahfidz without action
   */
  export type JamTahfidzArgs = {
    /**
     * Select specific fields to fetch from the JamTahfidz
     * 
    **/
    select?: JamTahfidzSelect | null
  }



  /**
   * Model AlQuran
   */


  export type AggregateAlQuran = {
    _count: AlQuranCountAggregateOutputType | null
    _avg: AlQuranAvgAggregateOutputType | null
    _sum: AlQuranSumAggregateOutputType | null
    _min: AlQuranMinAggregateOutputType | null
    _max: AlQuranMaxAggregateOutputType | null
  }

  export type AlQuranAvgAggregateOutputType = {
    id: number | null
    ayat: number | null
    baris: number | null
    halaman: number | null
    surah: number | null
    juz: number | null
  }

  export type AlQuranSumAggregateOutputType = {
    id: number | null
    ayat: number | null
    baris: number | null
    halaman: number | null
    surah: number | null
    juz: number | null
  }

  export type AlQuranMinAggregateOutputType = {
    id: number | null
    ayat: number | null
    baris: number | null
    halaman: number | null
    surah: number | null
    juz: number | null
    deleted: boolean | null
  }

  export type AlQuranMaxAggregateOutputType = {
    id: number | null
    ayat: number | null
    baris: number | null
    halaman: number | null
    surah: number | null
    juz: number | null
    deleted: boolean | null
  }

  export type AlQuranCountAggregateOutputType = {
    id: number
    ayat: number
    baris: number
    halaman: number
    surah: number
    juz: number
    deleted: number
    _all: number
  }


  export type AlQuranAvgAggregateInputType = {
    id?: true
    ayat?: true
    baris?: true
    halaman?: true
    surah?: true
    juz?: true
  }

  export type AlQuranSumAggregateInputType = {
    id?: true
    ayat?: true
    baris?: true
    halaman?: true
    surah?: true
    juz?: true
  }

  export type AlQuranMinAggregateInputType = {
    id?: true
    ayat?: true
    baris?: true
    halaman?: true
    surah?: true
    juz?: true
    deleted?: true
  }

  export type AlQuranMaxAggregateInputType = {
    id?: true
    ayat?: true
    baris?: true
    halaman?: true
    surah?: true
    juz?: true
    deleted?: true
  }

  export type AlQuranCountAggregateInputType = {
    id?: true
    ayat?: true
    baris?: true
    halaman?: true
    surah?: true
    juz?: true
    deleted?: true
    _all?: true
  }

  export type AlQuranAggregateArgs = {
    /**
     * Filter which AlQuran to aggregate.
     * 
    **/
    where?: AlQuranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlQurans to fetch.
     * 
    **/
    orderBy?: Enumerable<AlQuranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AlQuranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlQurans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlQurans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlQurans
    **/
    _count?: true | AlQuranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlQuranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlQuranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlQuranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlQuranMaxAggregateInputType
  }

  export type GetAlQuranAggregateType<T extends AlQuranAggregateArgs> = {
        [P in keyof T & keyof AggregateAlQuran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlQuran[P]>
      : GetScalarType<T[P], AggregateAlQuran[P]>
  }


    
    
  export type AlQuranGroupByArgs = {
    where?: AlQuranWhereInput
    orderBy?: Enumerable<AlQuranOrderByWithAggregationInput>
    by: Array<AlQuranScalarFieldEnum>
    having?: AlQuranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlQuranCountAggregateInputType | true
    _avg?: AlQuranAvgAggregateInputType
    _sum?: AlQuranSumAggregateInputType
    _min?: AlQuranMinAggregateInputType
    _max?: AlQuranMaxAggregateInputType
  }


  export type AlQuranGroupByOutputType = {
    id: number
    ayat: number
    baris: number
    halaman: number
    surah: number
    juz: number
    deleted: boolean
    _count: AlQuranCountAggregateOutputType | null
    _avg: AlQuranAvgAggregateOutputType | null
    _sum: AlQuranSumAggregateOutputType | null
    _min: AlQuranMinAggregateOutputType | null
    _max: AlQuranMaxAggregateOutputType | null
  }

  type GetAlQuranGroupByPayload<T extends AlQuranGroupByArgs> = Promise<
    Array<
      PickArray<AlQuranGroupByOutputType, T['by']> & 
        {
          [P in ((keyof T) & (keyof AlQuranGroupByOutputType))]: P extends '_count' 
            ? T[P] extends boolean 
              ? number 
              : GetScalarType<T[P], AlQuranGroupByOutputType[P]> 
            : GetScalarType<T[P], AlQuranGroupByOutputType[P]>
        }
      > 
    >


  export type AlQuranSelect = {
    id?: boolean
    ayat?: boolean
    baris?: boolean
    halaman?: boolean
    surah?: boolean
    juz?: boolean
    deleted?: boolean
  }

  export type AlQuranGetPayload<
    S extends boolean | null | undefined | AlQuranArgs,
    U = keyof S
      > = S extends true
        ? AlQuran
    : S extends undefined
    ? never
    : S extends AlQuranArgs | AlQuranFindManyArgs
    ?'include' extends U
    ? AlQuran 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof AlQuran ?AlQuran [P]
  : 
     never
  } 
    : AlQuran
  : AlQuran


  type AlQuranCountArgs = Merge<
    Omit<AlQuranFindManyArgs, 'select' | 'include'> & {
      select?: AlQuranCountAggregateInputType | true
    }
  >

  export interface AlQuranDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one AlQuran that matches the filter.
     * @param {AlQuranFindUniqueArgs} args - Arguments to find a AlQuran
     * @example
     * // Get one AlQuran
     * const alQuran = await prisma.alQuran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AlQuranFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AlQuranFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AlQuran'> extends True ? CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>> : CheckSelect<T, Prisma__AlQuranClient<AlQuran | null >, Prisma__AlQuranClient<AlQuranGetPayload<T> | null >>

    /**
     * Find the first AlQuran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranFindFirstArgs} args - Arguments to find a AlQuran
     * @example
     * // Get one AlQuran
     * const alQuran = await prisma.alQuran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AlQuranFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AlQuranFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AlQuran'> extends True ? CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>> : CheckSelect<T, Prisma__AlQuranClient<AlQuran | null >, Prisma__AlQuranClient<AlQuranGetPayload<T> | null >>

    /**
     * Find zero or more AlQurans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlQurans
     * const alQurans = await prisma.alQuran.findMany()
     * 
     * // Get first 10 AlQurans
     * const alQurans = await prisma.alQuran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alQuranWithIdOnly = await prisma.alQuran.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AlQuranFindManyArgs>(
      args?: SelectSubset<T, AlQuranFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<AlQuran>>, PrismaPromise<Array<AlQuranGetPayload<T>>>>

    /**
     * Create a AlQuran.
     * @param {AlQuranCreateArgs} args - Arguments to create a AlQuran.
     * @example
     * // Create one AlQuran
     * const AlQuran = await prisma.alQuran.create({
     *   data: {
     *     // ... data to create a AlQuran
     *   }
     * })
     * 
    **/
    create<T extends AlQuranCreateArgs>(
      args: SelectSubset<T, AlQuranCreateArgs>
    ): CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>>

    /**
     * Create many AlQurans.
     *     @param {AlQuranCreateManyArgs} args - Arguments to create many AlQurans.
     *     @example
     *     // Create many AlQurans
     *     const alQuran = await prisma.alQuran.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AlQuranCreateManyArgs>(
      args?: SelectSubset<T, AlQuranCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a AlQuran.
     * @param {AlQuranDeleteArgs} args - Arguments to delete one AlQuran.
     * @example
     * // Delete one AlQuran
     * const AlQuran = await prisma.alQuran.delete({
     *   where: {
     *     // ... filter to delete one AlQuran
     *   }
     * })
     * 
    **/
    delete<T extends AlQuranDeleteArgs>(
      args: SelectSubset<T, AlQuranDeleteArgs>
    ): CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>>

    /**
     * Update one AlQuran.
     * @param {AlQuranUpdateArgs} args - Arguments to update one AlQuran.
     * @example
     * // Update one AlQuran
     * const alQuran = await prisma.alQuran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AlQuranUpdateArgs>(
      args: SelectSubset<T, AlQuranUpdateArgs>
    ): CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>>

    /**
     * Delete zero or more AlQurans.
     * @param {AlQuranDeleteManyArgs} args - Arguments to filter AlQurans to delete.
     * @example
     * // Delete a few AlQurans
     * const { count } = await prisma.alQuran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AlQuranDeleteManyArgs>(
      args?: SelectSubset<T, AlQuranDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlQurans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlQurans
     * const alQuran = await prisma.alQuran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AlQuranUpdateManyArgs>(
      args: SelectSubset<T, AlQuranUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one AlQuran.
     * @param {AlQuranUpsertArgs} args - Arguments to update or create a AlQuran.
     * @example
     * // Update or create a AlQuran
     * const alQuran = await prisma.alQuran.upsert({
     *   create: {
     *     // ... data to create a AlQuran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlQuran we want to update
     *   }
     * })
    **/
    upsert<T extends AlQuranUpsertArgs>(
      args: SelectSubset<T, AlQuranUpsertArgs>
    ): CheckSelect<T, Prisma__AlQuranClient<AlQuran>, Prisma__AlQuranClient<AlQuranGetPayload<T>>>

    /**
     * Count the number of AlQurans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranCountArgs} args - Arguments to filter AlQurans to count.
     * @example
     * // Count the number of AlQurans
     * const count = await prisma.alQuran.count({
     *   where: {
     *     // ... the filter for the AlQurans we want to count
     *   }
     * })
    **/
    count<T extends AlQuranCountArgs>(
      args?: Subset<T, AlQuranCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlQuranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlQuran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlQuranAggregateArgs>(args: Subset<T, AlQuranAggregateArgs>): PrismaPromise<GetAlQuranAggregateType<T>>

    /**
     * Group by AlQuran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlQuranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlQuranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlQuranGroupByArgs['orderBy'] }
        : { orderBy?: AlQuranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlQuranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlQuranGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlQuran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AlQuranClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * AlQuran findUnique
   */
  export type AlQuranFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * Throw an Error if a AlQuran can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AlQuran to fetch.
     * 
    **/
    where: AlQuranWhereUniqueInput
  }


  /**
   * AlQuran findFirst
   */
  export type AlQuranFindFirstArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * Throw an Error if a AlQuran can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which AlQuran to fetch.
     * 
    **/
    where?: AlQuranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlQurans to fetch.
     * 
    **/
    orderBy?: Enumerable<AlQuranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlQurans.
     * 
    **/
    cursor?: AlQuranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlQurans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlQurans.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlQurans.
     * 
    **/
    distinct?: Enumerable<AlQuranScalarFieldEnum>
  }


  /**
   * AlQuran findMany
   */
  export type AlQuranFindManyArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * Filter, which AlQurans to fetch.
     * 
    **/
    where?: AlQuranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlQurans to fetch.
     * 
    **/
    orderBy?: Enumerable<AlQuranOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlQurans.
     * 
    **/
    cursor?: AlQuranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlQurans from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlQurans.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AlQuranScalarFieldEnum>
  }


  /**
   * AlQuran create
   */
  export type AlQuranCreateArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * The data needed to create a AlQuran.
     * 
    **/
    data: XOR<AlQuranCreateInput, AlQuranUncheckedCreateInput>
  }


  /**
   * AlQuran createMany
   */
  export type AlQuranCreateManyArgs = {
    data: Enumerable<AlQuranCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AlQuran update
   */
  export type AlQuranUpdateArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * The data needed to update a AlQuran.
     * 
    **/
    data: XOR<AlQuranUpdateInput, AlQuranUncheckedUpdateInput>
    /**
     * Choose, which AlQuran to update.
     * 
    **/
    where: AlQuranWhereUniqueInput
  }


  /**
   * AlQuran updateMany
   */
  export type AlQuranUpdateManyArgs = {
    data: XOR<AlQuranUpdateManyMutationInput, AlQuranUncheckedUpdateManyInput>
    where?: AlQuranWhereInput
  }


  /**
   * AlQuran upsert
   */
  export type AlQuranUpsertArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * The filter to search for the AlQuran to update in case it exists.
     * 
    **/
    where: AlQuranWhereUniqueInput
    /**
     * In case the AlQuran found by the `where` argument doesn't exist, create a new AlQuran with this data.
     * 
    **/
    create: XOR<AlQuranCreateInput, AlQuranUncheckedCreateInput>
    /**
     * In case the AlQuran was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AlQuranUpdateInput, AlQuranUncheckedUpdateInput>
  }


  /**
   * AlQuran delete
   */
  export type AlQuranDeleteArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
    /**
     * Filter which AlQuran to delete.
     * 
    **/
    where: AlQuranWhereUniqueInput
  }


  /**
   * AlQuran deleteMany
   */
  export type AlQuranDeleteManyArgs = {
    where?: AlQuranWhereInput
  }


  /**
   * AlQuran without action
   */
  export type AlQuranArgs = {
    /**
     * Select specific fields to fetch from the AlQuran
     * 
    **/
    select?: AlQuranSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    deleted: 'deleted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const GuruScalarFieldEnum: {
    id: 'id',
    nig: 'nig',
    nigs: 'nigs',
    kodeGuru: 'kodeGuru',
    nama: 'nama',
    email: 'email',
    jenisKelamin: 'jenisKelamin',
    tempatLahir: 'tempatLahir',
    tanggalLahir: 'tanggalLahir',
    tanggalMasuk: 'tanggalMasuk',
    profileUrl: 'profileUrl',
    deleted: 'deleted'
  };

  export type GuruScalarFieldEnum = (typeof GuruScalarFieldEnum)[keyof typeof GuruScalarFieldEnum]


  export const GuruDetailsScalarFieldEnum: {
    guruId: 'guruId',
    userId: 'userId'
  };

  export type GuruDetailsScalarFieldEnum = (typeof GuruDetailsScalarFieldEnum)[keyof typeof GuruDetailsScalarFieldEnum]


  export const GuruTahfidzDetailsScalarFieldEnum: {
    guruId: 'guruId',
    deleted: 'deleted'
  };

  export type GuruTahfidzDetailsScalarFieldEnum = (typeof GuruTahfidzDetailsScalarFieldEnum)[keyof typeof GuruTahfidzDetailsScalarFieldEnum]


  export const MuridScalarFieldEnum: {
    id: 'id',
    nis: 'nis',
    nism: 'nism',
    nisn: 'nisn',
    nama: 'nama',
    jenisKelamin: 'jenisKelamin',
    tempatLahir: 'tempatLahir',
    tanggalLahir: 'tanggalLahir',
    anakKe: 'anakKe',
    jumlahSaudaraKandung: 'jumlahSaudaraKandung',
    jumlahSaudaraTiri: 'jumlahSaudaraTiri',
    jumlahSaudaraAngkat: 'jumlahSaudaraAngkat',
    golonganDarah: 'golonganDarah',
    profileUrl: 'profileUrl',
    deleted: 'deleted'
  };

  export type MuridScalarFieldEnum = (typeof MuridScalarFieldEnum)[keyof typeof MuridScalarFieldEnum]


  export const MuridDetailsScalarFieldEnum: {
    muridId: 'muridId',
    userId: 'userId'
  };

  export type MuridDetailsScalarFieldEnum = (typeof MuridDetailsScalarFieldEnum)[keyof typeof MuridDetailsScalarFieldEnum]


  export const MuridTahfidzDetailsScalarFieldEnum: {
    muridId: 'muridId',
    kelompokTahfidzId: 'kelompokTahfidzId'
  };

  export type MuridTahfidzDetailsScalarFieldEnum = (typeof MuridTahfidzDetailsScalarFieldEnum)[keyof typeof MuridTahfidzDetailsScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    nip: 'nip',
    nama: 'nama',
    tempatLahir: 'tempatLahir',
    tanggalLahir: 'tanggalLahir',
    jenisKelamin: 'jenisKelamin',
    agama: 'agama',
    pendidikanTerakhir: 'pendidikanTerakhir',
    penghasilanPerBulan: 'penghasilanPerBulan',
    pekerjaan: 'pekerjaan',
    nomorTelepon: 'nomorTelepon',
    statusHidup: 'statusHidup',
    profileUrl: 'profileUrl',
    deleted: 'deleted'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const ParentDetailsScalarFieldEnum: {
    parentId: 'parentId',
    userId: 'userId'
  };

  export type ParentDetailsScalarFieldEnum = (typeof ParentDetailsScalarFieldEnum)[keyof typeof ParentDetailsScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    target: 'target',
    targetId: 'targetId',
    userId: 'userId',
    time: 'time'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const HalaqohScalarFieldEnum: {
    id: 'id',
    kode: 'kode',
    guruId: 'guruId'
  };

  export type HalaqohScalarFieldEnum = (typeof HalaqohScalarFieldEnum)[keyof typeof HalaqohScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    waktu: 'waktu',
    juz: 'juz',
    halaman: 'halaman',
    awalSetoran: 'awalSetoran',
    akhirSetoran: 'akhirSetoran',
    nilaiTajwid: 'nilaiTajwid',
    nilaiKelancaran: 'nilaiKelancaran',
    nilaiMakhroj: 'nilaiMakhroj',
    nilaiSifatHuruf: 'nilaiSifatHuruf',
    jamTahfidz: 'jamTahfidz',
    muridId: 'muridId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const JamTahfidzScalarFieldEnum: {
    id: 'id',
    waktuMulai: 'waktuMulai',
    waktuSelesai: 'waktuSelesai',
    namaJam: 'namaJam',
    tipe: 'tipe'
  };

  export type JamTahfidzScalarFieldEnum = (typeof JamTahfidzScalarFieldEnum)[keyof typeof JamTahfidzScalarFieldEnum]


  export const AlQuranScalarFieldEnum: {
    id: 'id',
    ayat: 'ayat',
    baris: 'baris',
    halaman: 'halaman',
    surah: 'surah',
    juz: 'juz',
    deleted: 'deleted'
  };

  export type AlQuranScalarFieldEnum = (typeof AlQuranScalarFieldEnum)[keyof typeof AlQuranScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    username?: StringFilter | string
    password?: StringFilter | string
    isGuru?: XOR<GuruDetailsRelationFilter, GuruDetailsWhereInput> | null
    isMurid?: XOR<MuridDetailsRelationFilter, MuridDetailsWhereInput> | null
    isParent?: XOR<ParentDetailsRelationFilter, ParentDetailsWhereInput> | null
    deleted?: BoolFilter | boolean
    roles?: RolesListRelationFilter
    auditLogs?: EventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    isGuru?: GuruDetailsOrderByWithRelationInput
    isMurid?: MuridDetailsOrderByWithRelationInput
    isParent?: ParentDetailsOrderByWithRelationInput
    deleted?: SortOrder
    roles?: RolesOrderByRelationAggregateInput
    auditLogs?: EventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type RolesWhereInput = {
    AND?: Enumerable<RolesWhereInput>
    OR?: Enumerable<RolesWhereInput>
    NOT?: Enumerable<RolesWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: EnumRoleFilter | Role
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: SortOrder
  }

  export type RolesWhereUniqueInput = {
    id?: number
  }

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RolesScalarWhereWithAggregatesInput>
    OR?: Enumerable<RolesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RolesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    role?: EnumRoleWithAggregatesFilter | Role
  }

  export type GuruWhereInput = {
    AND?: Enumerable<GuruWhereInput>
    OR?: Enumerable<GuruWhereInput>
    NOT?: Enumerable<GuruWhereInput>
    id?: IntFilter | number
    nig?: StringFilter | string
    nigs?: StringFilter | string
    kodeGuru?: StringFilter | string
    nama?: StringFilter | string
    email?: StringFilter | string
    jenisKelamin?: EnumJenisKelaminFilter | JenisKelamin
    tempatLahir?: StringFilter | string
    tanggalLahir?: DateTimeFilter | Date | string
    tanggalMasuk?: DateTimeFilter | Date | string
    profileUrl?: StringNullableFilter | string | null
    deleted?: BoolFilter | boolean
    guruDetails?: XOR<GuruDetailsRelationFilter, GuruDetailsWhereInput> | null
  }

  export type GuruOrderByWithRelationInput = {
    id?: SortOrder
    nig?: SortOrder
    nigs?: SortOrder
    kodeGuru?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    tanggalMasuk?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    guruDetails?: GuruDetailsOrderByWithRelationInput
  }

  export type GuruWhereUniqueInput = {
    id?: number
    nig?: string
    nigs?: string
    kodeGuru?: string
  }

  export type GuruOrderByWithAggregationInput = {
    id?: SortOrder
    nig?: SortOrder
    nigs?: SortOrder
    kodeGuru?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    tanggalMasuk?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    _count?: GuruCountOrderByAggregateInput
    _avg?: GuruAvgOrderByAggregateInput
    _max?: GuruMaxOrderByAggregateInput
    _min?: GuruMinOrderByAggregateInput
    _sum?: GuruSumOrderByAggregateInput
  }

  export type GuruScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuruScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuruScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuruScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nig?: StringWithAggregatesFilter | string
    nigs?: StringWithAggregatesFilter | string
    kodeGuru?: StringWithAggregatesFilter | string
    nama?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    jenisKelamin?: EnumJenisKelaminWithAggregatesFilter | JenisKelamin
    tempatLahir?: StringWithAggregatesFilter | string
    tanggalLahir?: DateTimeWithAggregatesFilter | Date | string
    tanggalMasuk?: DateTimeWithAggregatesFilter | Date | string
    profileUrl?: StringNullableWithAggregatesFilter | string | null
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type GuruDetailsWhereInput = {
    AND?: Enumerable<GuruDetailsWhereInput>
    OR?: Enumerable<GuruDetailsWhereInput>
    NOT?: Enumerable<GuruDetailsWhereInput>
    guru?: XOR<GuruRelationFilter, GuruWhereInput>
    guruId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    guruTahfidzDetail?: XOR<GuruTahfidzDetailsRelationFilter, GuruTahfidzDetailsWhereInput> | null
  }

  export type GuruDetailsOrderByWithRelationInput = {
    guru?: GuruOrderByWithRelationInput
    guruId?: SortOrder
    user?: UserOrderByWithRelationInput
    userId?: SortOrder
    guruTahfidzDetail?: GuruTahfidzDetailsOrderByWithRelationInput
  }

  export type GuruDetailsWhereUniqueInput = {
    guruId?: number
    userId?: number
  }

  export type GuruDetailsOrderByWithAggregationInput = {
    guruId?: SortOrder
    userId?: SortOrder
    _count?: GuruDetailsCountOrderByAggregateInput
    _avg?: GuruDetailsAvgOrderByAggregateInput
    _max?: GuruDetailsMaxOrderByAggregateInput
    _min?: GuruDetailsMinOrderByAggregateInput
    _sum?: GuruDetailsSumOrderByAggregateInput
  }

  export type GuruDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuruDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuruDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuruDetailsScalarWhereWithAggregatesInput>
    guruId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type GuruTahfidzDetailsWhereInput = {
    AND?: Enumerable<GuruTahfidzDetailsWhereInput>
    OR?: Enumerable<GuruTahfidzDetailsWhereInput>
    NOT?: Enumerable<GuruTahfidzDetailsWhereInput>
    guruId?: IntFilter | number
    guruDetails?: XOR<GuruDetailsRelationFilter, GuruDetailsWhereInput>
    deleted?: BoolFilter | boolean
    kelompokTahfidz?: HalaqohListRelationFilter
  }

  export type GuruTahfidzDetailsOrderByWithRelationInput = {
    guruId?: SortOrder
    guruDetails?: GuruDetailsOrderByWithRelationInput
    deleted?: SortOrder
    kelompokTahfidz?: HalaqohOrderByRelationAggregateInput
  }

  export type GuruTahfidzDetailsWhereUniqueInput = {
    guruId?: number
  }

  export type GuruTahfidzDetailsOrderByWithAggregationInput = {
    guruId?: SortOrder
    deleted?: SortOrder
    _count?: GuruTahfidzDetailsCountOrderByAggregateInput
    _avg?: GuruTahfidzDetailsAvgOrderByAggregateInput
    _max?: GuruTahfidzDetailsMaxOrderByAggregateInput
    _min?: GuruTahfidzDetailsMinOrderByAggregateInput
    _sum?: GuruTahfidzDetailsSumOrderByAggregateInput
  }

  export type GuruTahfidzDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GuruTahfidzDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GuruTahfidzDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GuruTahfidzDetailsScalarWhereWithAggregatesInput>
    guruId?: IntWithAggregatesFilter | number
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type MuridWhereInput = {
    AND?: Enumerable<MuridWhereInput>
    OR?: Enumerable<MuridWhereInput>
    NOT?: Enumerable<MuridWhereInput>
    id?: IntFilter | number
    nis?: StringFilter | string
    nism?: StringFilter | string
    nisn?: StringNullableFilter | string | null
    nama?: StringFilter | string
    jenisKelamin?: EnumJenisKelaminFilter | JenisKelamin
    tempatLahir?: StringFilter | string
    tanggalLahir?: DateTimeFilter | Date | string
    anakKe?: IntFilter | number
    jumlahSaudaraKandung?: IntFilter | number
    jumlahSaudaraTiri?: IntFilter | number
    jumlahSaudaraAngkat?: IntFilter | number
    golonganDarah?: EnumGolonganDarahNullableFilter | GolonganDarah | null
    profileUrl?: StringNullableFilter | string | null
    deleted?: BoolFilter | boolean
    muridDetails?: XOR<MuridDetailsRelationFilter, MuridDetailsWhereInput> | null
    orangTua?: ParentListRelationFilter
  }

  export type MuridOrderByWithRelationInput = {
    id?: SortOrder
    nis?: SortOrder
    nism?: SortOrder
    nisn?: SortOrder
    nama?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
    golonganDarah?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    muridDetails?: MuridDetailsOrderByWithRelationInput
    orangTua?: ParentOrderByRelationAggregateInput
  }

  export type MuridWhereUniqueInput = {
    id?: number
    nis?: string
    nism?: string
    nisn?: string
  }

  export type MuridOrderByWithAggregationInput = {
    id?: SortOrder
    nis?: SortOrder
    nism?: SortOrder
    nisn?: SortOrder
    nama?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
    golonganDarah?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    _count?: MuridCountOrderByAggregateInput
    _avg?: MuridAvgOrderByAggregateInput
    _max?: MuridMaxOrderByAggregateInput
    _min?: MuridMinOrderByAggregateInput
    _sum?: MuridSumOrderByAggregateInput
  }

  export type MuridScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MuridScalarWhereWithAggregatesInput>
    OR?: Enumerable<MuridScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MuridScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nis?: StringWithAggregatesFilter | string
    nism?: StringWithAggregatesFilter | string
    nisn?: StringNullableWithAggregatesFilter | string | null
    nama?: StringWithAggregatesFilter | string
    jenisKelamin?: EnumJenisKelaminWithAggregatesFilter | JenisKelamin
    tempatLahir?: StringWithAggregatesFilter | string
    tanggalLahir?: DateTimeWithAggregatesFilter | Date | string
    anakKe?: IntWithAggregatesFilter | number
    jumlahSaudaraKandung?: IntWithAggregatesFilter | number
    jumlahSaudaraTiri?: IntWithAggregatesFilter | number
    jumlahSaudaraAngkat?: IntWithAggregatesFilter | number
    golonganDarah?: EnumGolonganDarahNullableWithAggregatesFilter | GolonganDarah | null
    profileUrl?: StringNullableWithAggregatesFilter | string | null
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type MuridDetailsWhereInput = {
    AND?: Enumerable<MuridDetailsWhereInput>
    OR?: Enumerable<MuridDetailsWhereInput>
    NOT?: Enumerable<MuridDetailsWhereInput>
    muridId?: IntFilter | number
    murid?: XOR<MuridRelationFilter, MuridWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    tahfidzDetails?: XOR<MuridTahfidzDetailsRelationFilter, MuridTahfidzDetailsWhereInput> | null
  }

  export type MuridDetailsOrderByWithRelationInput = {
    muridId?: SortOrder
    murid?: MuridOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    tahfidzDetails?: MuridTahfidzDetailsOrderByWithRelationInput
  }

  export type MuridDetailsWhereUniqueInput = {
    muridId?: number
    userId?: number
  }

  export type MuridDetailsOrderByWithAggregationInput = {
    muridId?: SortOrder
    userId?: SortOrder
    _count?: MuridDetailsCountOrderByAggregateInput
    _avg?: MuridDetailsAvgOrderByAggregateInput
    _max?: MuridDetailsMaxOrderByAggregateInput
    _min?: MuridDetailsMinOrderByAggregateInput
    _sum?: MuridDetailsSumOrderByAggregateInput
  }

  export type MuridDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MuridDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MuridDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MuridDetailsScalarWhereWithAggregatesInput>
    muridId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type MuridTahfidzDetailsWhereInput = {
    AND?: Enumerable<MuridTahfidzDetailsWhereInput>
    OR?: Enumerable<MuridTahfidzDetailsWhereInput>
    NOT?: Enumerable<MuridTahfidzDetailsWhereInput>
    muridId?: IntFilter | number
    muridDetails?: XOR<MuridDetailsRelationFilter, MuridDetailsWhereInput>
    kelompokTahfidzId?: IntFilter | number
    kelompokTahfidz?: XOR<HalaqohRelationFilter, HalaqohWhereInput>
    sesi?: SessionListRelationFilter
  }

  export type MuridTahfidzDetailsOrderByWithRelationInput = {
    muridId?: SortOrder
    muridDetails?: MuridDetailsOrderByWithRelationInput
    kelompokTahfidzId?: SortOrder
    kelompokTahfidz?: HalaqohOrderByWithRelationInput
    sesi?: SessionOrderByRelationAggregateInput
  }

  export type MuridTahfidzDetailsWhereUniqueInput = {
    muridId?: number
  }

  export type MuridTahfidzDetailsOrderByWithAggregationInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
    _count?: MuridTahfidzDetailsCountOrderByAggregateInput
    _avg?: MuridTahfidzDetailsAvgOrderByAggregateInput
    _max?: MuridTahfidzDetailsMaxOrderByAggregateInput
    _min?: MuridTahfidzDetailsMinOrderByAggregateInput
    _sum?: MuridTahfidzDetailsSumOrderByAggregateInput
  }

  export type MuridTahfidzDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MuridTahfidzDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<MuridTahfidzDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MuridTahfidzDetailsScalarWhereWithAggregatesInput>
    muridId?: IntWithAggregatesFilter | number
    kelompokTahfidzId?: IntWithAggregatesFilter | number
  }

  export type ParentWhereInput = {
    AND?: Enumerable<ParentWhereInput>
    OR?: Enumerable<ParentWhereInput>
    NOT?: Enumerable<ParentWhereInput>
    id?: IntFilter | number
    nip?: StringFilter | string
    nama?: StringFilter | string
    tempatLahir?: StringFilter | string
    tanggalLahir?: DateTimeFilter | Date | string
    jenisKelamin?: EnumJenisKelaminFilter | JenisKelamin
    agama?: EnumAgamaFilter | Agama
    pendidikanTerakhir?: EnumPendidikanFilter | Pendidikan
    penghasilanPerBulan?: IntFilter | number
    pekerjaan?: StringFilter | string
    nomorTelepon?: StringFilter | string
    statusHidup?: EnumHidupFilter | Hidup
    profileUrl?: StringNullableFilter | string | null
    deleted?: BoolFilter | boolean
    parentDetails?: XOR<ParentDetailsRelationFilter, ParentDetailsWhereInput> | null
    daftarAnak?: MuridListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    agama?: SortOrder
    pendidikanTerakhir?: SortOrder
    penghasilanPerBulan?: SortOrder
    pekerjaan?: SortOrder
    nomorTelepon?: SortOrder
    statusHidup?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    parentDetails?: ParentDetailsOrderByWithRelationInput
    daftarAnak?: MuridOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = {
    id?: number
    nip?: string
  }

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    agama?: SortOrder
    pendidikanTerakhir?: SortOrder
    penghasilanPerBulan?: SortOrder
    pekerjaan?: SortOrder
    nomorTelepon?: SortOrder
    statusHidup?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _avg?: ParentAvgOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
    _sum?: ParentSumOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nip?: StringWithAggregatesFilter | string
    nama?: StringWithAggregatesFilter | string
    tempatLahir?: StringWithAggregatesFilter | string
    tanggalLahir?: DateTimeWithAggregatesFilter | Date | string
    jenisKelamin?: EnumJenisKelaminWithAggregatesFilter | JenisKelamin
    agama?: EnumAgamaWithAggregatesFilter | Agama
    pendidikanTerakhir?: EnumPendidikanWithAggregatesFilter | Pendidikan
    penghasilanPerBulan?: IntWithAggregatesFilter | number
    pekerjaan?: StringWithAggregatesFilter | string
    nomorTelepon?: StringWithAggregatesFilter | string
    statusHidup?: EnumHidupWithAggregatesFilter | Hidup
    profileUrl?: StringNullableWithAggregatesFilter | string | null
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type ParentDetailsWhereInput = {
    AND?: Enumerable<ParentDetailsWhereInput>
    OR?: Enumerable<ParentDetailsWhereInput>
    NOT?: Enumerable<ParentDetailsWhereInput>
    parentId?: IntFilter | number
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
    userId?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ParentDetailsOrderByWithRelationInput = {
    parentId?: SortOrder
    parent?: ParentOrderByWithRelationInput
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ParentDetailsWhereUniqueInput = {
    parentId?: number
    userId?: number
  }

  export type ParentDetailsOrderByWithAggregationInput = {
    parentId?: SortOrder
    userId?: SortOrder
    _count?: ParentDetailsCountOrderByAggregateInput
    _avg?: ParentDetailsAvgOrderByAggregateInput
    _max?: ParentDetailsMaxOrderByAggregateInput
    _min?: ParentDetailsMinOrderByAggregateInput
    _sum?: ParentDetailsSumOrderByAggregateInput
  }

  export type ParentDetailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ParentDetailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ParentDetailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ParentDetailsScalarWhereWithAggregatesInput>
    parentId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
  }

  export type EventWhereInput = {
    AND?: Enumerable<EventWhereInput>
    OR?: Enumerable<EventWhereInput>
    NOT?: Enumerable<EventWhereInput>
    id?: IntFilter | number
    type?: EnumTipeEventFilter | TipeEvent
    target?: EnumEventModelTypeFilter | EventModelType
    targetId?: IntFilter | number
    actor?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    time?: DateTimeFilter | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    actor?: UserOrderByWithRelationInput
    userId?: SortOrder
    time?: SortOrder
  }

  export type EventWhereUniqueInput = {
    id?: number
  }

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
    time?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EventScalarWhereWithAggregatesInput>
    OR?: Enumerable<EventScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EventScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumTipeEventWithAggregatesFilter | TipeEvent
    target?: EnumEventModelTypeWithAggregatesFilter | EventModelType
    targetId?: IntWithAggregatesFilter | number
    userId?: IntWithAggregatesFilter | number
    time?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HalaqohWhereInput = {
    AND?: Enumerable<HalaqohWhereInput>
    OR?: Enumerable<HalaqohWhereInput>
    NOT?: Enumerable<HalaqohWhereInput>
    id?: IntFilter | number
    kode?: StringFilter | string
    guruId?: IntFilter | number
    guruTahfidzDetail?: XOR<GuruTahfidzDetailsRelationFilter, GuruTahfidzDetailsWhereInput>
    muridTahfidzDetail?: MuridTahfidzDetailsListRelationFilter
  }

  export type HalaqohOrderByWithRelationInput = {
    id?: SortOrder
    kode?: SortOrder
    guruId?: SortOrder
    guruTahfidzDetail?: GuruTahfidzDetailsOrderByWithRelationInput
    muridTahfidzDetail?: MuridTahfidzDetailsOrderByRelationAggregateInput
  }

  export type HalaqohWhereUniqueInput = {
    id?: number
    kode?: string
  }

  export type HalaqohOrderByWithAggregationInput = {
    id?: SortOrder
    kode?: SortOrder
    guruId?: SortOrder
    _count?: HalaqohCountOrderByAggregateInput
    _avg?: HalaqohAvgOrderByAggregateInput
    _max?: HalaqohMaxOrderByAggregateInput
    _min?: HalaqohMinOrderByAggregateInput
    _sum?: HalaqohSumOrderByAggregateInput
  }

  export type HalaqohScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HalaqohScalarWhereWithAggregatesInput>
    OR?: Enumerable<HalaqohScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HalaqohScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    kode?: StringWithAggregatesFilter | string
    guruId?: IntWithAggregatesFilter | number
  }

  export type SessionWhereInput = {
    AND?: Enumerable<SessionWhereInput>
    OR?: Enumerable<SessionWhereInput>
    NOT?: Enumerable<SessionWhereInput>
    id?: IntFilter | number
    type?: EnumTipeSesiFilter | TipeSesi
    waktu?: DateTimeFilter | Date | string
    juz?: IntFilter | number
    halaman?: IntFilter | number
    awalSetoran?: StringFilter | string
    akhirSetoran?: StringFilter | string
    nilaiTajwid?: IntFilter | number
    nilaiKelancaran?: IntFilter | number
    nilaiMakhroj?: IntFilter | number
    nilaiSifatHuruf?: IntFilter | number
    jamTahfidz?: StringFilter | string
    muridId?: IntFilter | number
    muridTahfidzDetail?: XOR<MuridTahfidzDetailsRelationFilter, MuridTahfidzDetailsWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    awalSetoran?: SortOrder
    akhirSetoran?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    jamTahfidz?: SortOrder
    muridId?: SortOrder
    muridTahfidzDetail?: MuridTahfidzDetailsOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = {
    id?: number
  }

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    awalSetoran?: SortOrder
    akhirSetoran?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    jamTahfidz?: SortOrder
    muridId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumTipeSesiWithAggregatesFilter | TipeSesi
    waktu?: DateTimeWithAggregatesFilter | Date | string
    juz?: IntWithAggregatesFilter | number
    halaman?: IntWithAggregatesFilter | number
    awalSetoran?: StringWithAggregatesFilter | string
    akhirSetoran?: StringWithAggregatesFilter | string
    nilaiTajwid?: IntWithAggregatesFilter | number
    nilaiKelancaran?: IntWithAggregatesFilter | number
    nilaiMakhroj?: IntWithAggregatesFilter | number
    nilaiSifatHuruf?: IntWithAggregatesFilter | number
    jamTahfidz?: StringWithAggregatesFilter | string
    muridId?: IntWithAggregatesFilter | number
  }

  export type JamTahfidzWhereInput = {
    AND?: Enumerable<JamTahfidzWhereInput>
    OR?: Enumerable<JamTahfidzWhereInput>
    NOT?: Enumerable<JamTahfidzWhereInput>
    id?: IntFilter | number
    waktuMulai?: DateTimeFilter | Date | string
    waktuSelesai?: DateTimeFilter | Date | string
    namaJam?: StringFilter | string
    tipe?: EnumTipeSesiFilter | TipeSesi
  }

  export type JamTahfidzOrderByWithRelationInput = {
    id?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    namaJam?: SortOrder
    tipe?: SortOrder
  }

  export type JamTahfidzWhereUniqueInput = {
    id?: number
  }

  export type JamTahfidzOrderByWithAggregationInput = {
    id?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    namaJam?: SortOrder
    tipe?: SortOrder
    _count?: JamTahfidzCountOrderByAggregateInput
    _avg?: JamTahfidzAvgOrderByAggregateInput
    _max?: JamTahfidzMaxOrderByAggregateInput
    _min?: JamTahfidzMinOrderByAggregateInput
    _sum?: JamTahfidzSumOrderByAggregateInput
  }

  export type JamTahfidzScalarWhereWithAggregatesInput = {
    AND?: Enumerable<JamTahfidzScalarWhereWithAggregatesInput>
    OR?: Enumerable<JamTahfidzScalarWhereWithAggregatesInput>
    NOT?: Enumerable<JamTahfidzScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    waktuMulai?: DateTimeWithAggregatesFilter | Date | string
    waktuSelesai?: DateTimeWithAggregatesFilter | Date | string
    namaJam?: StringWithAggregatesFilter | string
    tipe?: EnumTipeSesiWithAggregatesFilter | TipeSesi
  }

  export type AlQuranWhereInput = {
    AND?: Enumerable<AlQuranWhereInput>
    OR?: Enumerable<AlQuranWhereInput>
    NOT?: Enumerable<AlQuranWhereInput>
    id?: IntFilter | number
    ayat?: IntFilter | number
    baris?: IntFilter | number
    halaman?: IntFilter | number
    surah?: IntFilter | number
    juz?: IntFilter | number
    deleted?: BoolFilter | boolean
  }

  export type AlQuranOrderByWithRelationInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
    deleted?: SortOrder
  }

  export type AlQuranWhereUniqueInput = {
    id?: number
  }

  export type AlQuranOrderByWithAggregationInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
    deleted?: SortOrder
    _count?: AlQuranCountOrderByAggregateInput
    _avg?: AlQuranAvgOrderByAggregateInput
    _max?: AlQuranMaxOrderByAggregateInput
    _min?: AlQuranMinOrderByAggregateInput
    _sum?: AlQuranSumOrderByAggregateInput
  }

  export type AlQuranScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AlQuranScalarWhereWithAggregatesInput>
    OR?: Enumerable<AlQuranScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AlQuranScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ayat?: IntWithAggregatesFilter | number
    baris?: IntWithAggregatesFilter | number
    halaman?: IntWithAggregatesFilter | number
    surah?: IntWithAggregatesFilter | number
    juz?: IntWithAggregatesFilter | number
    deleted?: BoolWithAggregatesFilter | boolean
  }

  export type UserCreateInput = {
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsCreateNestedOneWithoutUserInput
    roles?: RolesCreateNestedManyWithoutUserInput
    auditLogs?: EventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsUncheckedCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsUncheckedCreateNestedOneWithoutUserInput
    roles?: RolesUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: EventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUpdateOneWithoutUserInput
    isParent?: ParentDetailsUpdateOneWithoutUserInput
    roles?: RolesUpdateManyWithoutUserInput
    auditLogs?: EventUpdateManyWithoutActorInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUncheckedUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedUpdateOneWithoutUserInput
    isParent?: ParentDetailsUncheckedUpdateOneWithoutUserInput
    roles?: RolesUncheckedUpdateManyWithoutUserInput
    auditLogs?: EventUncheckedUpdateManyWithoutActorInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RolesCreateInput = {
    role: Role
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    userId: number
    role: Role
  }

  export type RolesUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
    user?: UserUpdateOneRequiredWithoutRolesInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type RolesCreateManyInput = {
    id?: number
    userId: number
    role: Role
  }

  export type RolesUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type GuruCreateInput = {
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    tanggalMasuk: Date | string
    profileUrl?: string | null
    deleted?: boolean
    guruDetails?: GuruDetailsCreateNestedOneWithoutGuruInput
  }

  export type GuruUncheckedCreateInput = {
    id?: number
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    tanggalMasuk: Date | string
    profileUrl?: string | null
    deleted?: boolean
    guruDetails?: GuruDetailsUncheckedCreateNestedOneWithoutGuruInput
  }

  export type GuruUpdateInput = {
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    guruDetails?: GuruDetailsUpdateOneWithoutGuruInput
  }

  export type GuruUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    guruDetails?: GuruDetailsUncheckedUpdateOneWithoutGuruInput
  }

  export type GuruCreateManyInput = {
    id?: number
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    tanggalMasuk: Date | string
    profileUrl?: string | null
    deleted?: boolean
  }

  export type GuruUpdateManyMutationInput = {
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuruUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuruDetailsCreateInput = {
    guru: GuruCreateNestedOneWithoutGuruDetailsInput
    user: UserCreateNestedOneWithoutIsGuruInput
    guruTahfidzDetail?: GuruTahfidzDetailsCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedCreateInput = {
    guruId: number
    userId: number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUpdateInput = {
    guru?: GuruUpdateOneRequiredWithoutGuruDetailsInput
    user?: UserUpdateOneRequiredWithoutIsGuruInput
    guruTahfidzDetail?: GuruTahfidzDetailsUpdateOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedUpdateInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedUpdateOneWithoutGuruDetailsInput
  }

  export type GuruDetailsCreateManyInput = {
    guruId: number
    userId: number
  }

  export type GuruDetailsUpdateManyMutationInput = {

  }

  export type GuruDetailsUncheckedUpdateManyInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type GuruTahfidzDetailsCreateInput = {
    deleted?: boolean
    guruDetails: GuruDetailsCreateNestedOneWithoutGuruTahfidzDetailInput
    kelompokTahfidz?: HalaqohCreateNestedManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedCreateInput = {
    guruId: number
    deleted?: boolean
    kelompokTahfidz?: HalaqohUncheckedCreateNestedManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUpdateInput = {
    deleted?: BoolFieldUpdateOperationsInput | boolean
    guruDetails?: GuruDetailsUpdateOneRequiredWithoutGuruTahfidzDetailInput
    kelompokTahfidz?: HalaqohUpdateManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedUpdateInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
    kelompokTahfidz?: HalaqohUncheckedUpdateManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsCreateManyInput = {
    guruId: number
    deleted?: boolean
  }

  export type GuruTahfidzDetailsUpdateManyMutationInput = {
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuruTahfidzDetailsUncheckedUpdateManyInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MuridCreateInput = {
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
    muridDetails?: MuridDetailsCreateNestedOneWithoutMuridInput
    orangTua?: ParentCreateNestedManyWithoutDaftarAnakInput
  }

  export type MuridUncheckedCreateInput = {
    id?: number
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
    muridDetails?: MuridDetailsUncheckedCreateNestedOneWithoutMuridInput
  }

  export type MuridUpdateInput = {
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    muridDetails?: MuridDetailsUpdateOneWithoutMuridInput
    orangTua?: ParentUpdateManyWithoutDaftarAnakInput
  }

  export type MuridUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    muridDetails?: MuridDetailsUncheckedUpdateOneWithoutMuridInput
  }

  export type MuridCreateManyInput = {
    id?: number
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
  }

  export type MuridUpdateManyMutationInput = {
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MuridUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MuridDetailsCreateInput = {
    murid: MuridCreateNestedOneWithoutMuridDetailsInput
    user: UserCreateNestedOneWithoutIsMuridInput
    tahfidzDetails?: MuridTahfidzDetailsCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedCreateInput = {
    muridId: number
    userId: number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUpdateInput = {
    murid?: MuridUpdateOneRequiredWithoutMuridDetailsInput
    user?: UserUpdateOneRequiredWithoutIsMuridInput
    tahfidzDetails?: MuridTahfidzDetailsUpdateOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedUpdateInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedUpdateOneWithoutMuridDetailsInput
  }

  export type MuridDetailsCreateManyInput = {
    muridId: number
    userId: number
  }

  export type MuridDetailsUpdateManyMutationInput = {

  }

  export type MuridDetailsUncheckedUpdateManyInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MuridTahfidzDetailsCreateInput = {
    muridDetails: MuridDetailsCreateNestedOneWithoutTahfidzDetailsInput
    kelompokTahfidz: HalaqohCreateNestedOneWithoutMuridTahfidzDetailInput
    sesi?: SessionCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedCreateInput = {
    muridId: number
    kelompokTahfidzId: number
    sesi?: SessionUncheckedCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUpdateInput = {
    muridDetails?: MuridDetailsUpdateOneRequiredWithoutTahfidzDetailsInput
    kelompokTahfidz?: HalaqohUpdateOneRequiredWithoutMuridTahfidzDetailInput
    sesi?: SessionUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedUpdateInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    kelompokTahfidzId?: IntFieldUpdateOperationsInput | number
    sesi?: SessionUncheckedUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsCreateManyInput = {
    muridId: number
    kelompokTahfidzId: number
  }

  export type MuridTahfidzDetailsUpdateManyMutationInput = {

  }

  export type MuridTahfidzDetailsUncheckedUpdateManyInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    kelompokTahfidzId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentCreateInput = {
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
    parentDetails?: ParentDetailsCreateNestedOneWithoutParentInput
    daftarAnak?: MuridCreateNestedManyWithoutOrangTuaInput
  }

  export type ParentUncheckedCreateInput = {
    id?: number
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
    parentDetails?: ParentDetailsUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentUpdateInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    parentDetails?: ParentDetailsUpdateOneWithoutParentInput
    daftarAnak?: MuridUpdateManyWithoutOrangTuaInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    parentDetails?: ParentDetailsUncheckedUpdateOneWithoutParentInput
  }

  export type ParentCreateManyInput = {
    id?: number
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
  }

  export type ParentUpdateManyMutationInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParentDetailsCreateInput = {
    parent: ParentCreateNestedOneWithoutParentDetailsInput
    user: UserCreateNestedOneWithoutIsParentInput
  }

  export type ParentDetailsUncheckedCreateInput = {
    parentId: number
    userId: number
  }

  export type ParentDetailsUpdateInput = {
    parent?: ParentUpdateOneRequiredWithoutParentDetailsInput
    user?: UserUpdateOneRequiredWithoutIsParentInput
  }

  export type ParentDetailsUncheckedUpdateInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ParentDetailsCreateManyInput = {
    parentId: number
    userId: number
  }

  export type ParentDetailsUpdateManyMutationInput = {

  }

  export type ParentDetailsUncheckedUpdateManyInput = {
    parentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type EventCreateInput = {
    type: TipeEvent
    target: EventModelType
    targetId: number
    time?: Date | string
    actor: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    type: TipeEvent
    target: EventModelType
    targetId: number
    userId: number
    time?: Date | string
  }

  export type EventUpdateInput = {
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditLogsInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: number
    type: TipeEvent
    target: EventModelType
    targetId: number
    userId: number
    time?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HalaqohCreateInput = {
    kode: string
    guruTahfidzDetail: GuruTahfidzDetailsCreateNestedOneWithoutKelompokTahfidzInput
    muridTahfidzDetail?: MuridTahfidzDetailsCreateNestedManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedCreateInput = {
    id?: number
    kode: string
    guruId: number
    muridTahfidzDetail?: MuridTahfidzDetailsUncheckedCreateNestedManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUpdateInput = {
    kode?: StringFieldUpdateOperationsInput | string
    guruTahfidzDetail?: GuruTahfidzDetailsUpdateOneRequiredWithoutKelompokTahfidzInput
    muridTahfidzDetail?: MuridTahfidzDetailsUpdateManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    guruId?: IntFieldUpdateOperationsInput | number
    muridTahfidzDetail?: MuridTahfidzDetailsUncheckedUpdateManyWithoutKelompokTahfidzInput
  }

  export type HalaqohCreateManyInput = {
    id?: number
    kode: string
    guruId: number
  }

  export type HalaqohUpdateManyMutationInput = {
    kode?: StringFieldUpdateOperationsInput | string
  }

  export type HalaqohUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    guruId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateInput = {
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
    muridTahfidzDetail: MuridTahfidzDetailsCreateNestedOneWithoutSesiInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
    muridId: number
  }

  export type SessionUpdateInput = {
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
    muridTahfidzDetail?: MuridTahfidzDetailsUpdateOneRequiredWithoutSesiInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
    muridId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionCreateManyInput = {
    id?: number
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
    muridId: number
  }

  export type SessionUpdateManyMutationInput = {
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
    muridId?: IntFieldUpdateOperationsInput | number
  }

  export type JamTahfidzCreateInput = {
    waktuMulai: Date | string
    waktuSelesai: Date | string
    namaJam: string
    tipe: TipeSesi
  }

  export type JamTahfidzUncheckedCreateInput = {
    id?: number
    waktuMulai: Date | string
    waktuSelesai: Date | string
    namaJam: string
    tipe: TipeSesi
  }

  export type JamTahfidzUpdateInput = {
    waktuMulai?: DateTimeFieldUpdateOperationsInput | Date | string
    waktuSelesai?: DateTimeFieldUpdateOperationsInput | Date | string
    namaJam?: StringFieldUpdateOperationsInput | string
    tipe?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
  }

  export type JamTahfidzUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktuMulai?: DateTimeFieldUpdateOperationsInput | Date | string
    waktuSelesai?: DateTimeFieldUpdateOperationsInput | Date | string
    namaJam?: StringFieldUpdateOperationsInput | string
    tipe?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
  }

  export type JamTahfidzCreateManyInput = {
    id?: number
    waktuMulai: Date | string
    waktuSelesai: Date | string
    namaJam: string
    tipe: TipeSesi
  }

  export type JamTahfidzUpdateManyMutationInput = {
    waktuMulai?: DateTimeFieldUpdateOperationsInput | Date | string
    waktuSelesai?: DateTimeFieldUpdateOperationsInput | Date | string
    namaJam?: StringFieldUpdateOperationsInput | string
    tipe?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
  }

  export type JamTahfidzUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    waktuMulai?: DateTimeFieldUpdateOperationsInput | Date | string
    waktuSelesai?: DateTimeFieldUpdateOperationsInput | Date | string
    namaJam?: StringFieldUpdateOperationsInput | string
    tipe?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
  }

  export type AlQuranCreateInput = {
    ayat: number
    baris: number
    halaman: number
    surah: number
    juz: number
    deleted?: boolean
  }

  export type AlQuranUncheckedCreateInput = {
    id?: number
    ayat: number
    baris: number
    halaman: number
    surah: number
    juz: number
    deleted?: boolean
  }

  export type AlQuranUpdateInput = {
    ayat?: IntFieldUpdateOperationsInput | number
    baris?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    surah?: IntFieldUpdateOperationsInput | number
    juz?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlQuranUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ayat?: IntFieldUpdateOperationsInput | number
    baris?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    surah?: IntFieldUpdateOperationsInput | number
    juz?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlQuranCreateManyInput = {
    id?: number
    ayat: number
    baris: number
    halaman: number
    surah: number
    juz: number
    deleted?: boolean
  }

  export type AlQuranUpdateManyMutationInput = {
    ayat?: IntFieldUpdateOperationsInput | number
    baris?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    surah?: IntFieldUpdateOperationsInput | number
    juz?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AlQuranUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ayat?: IntFieldUpdateOperationsInput | number
    baris?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    surah?: IntFieldUpdateOperationsInput | number
    juz?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type GuruDetailsRelationFilter = {
    is?: GuruDetailsWhereInput | null
    isNot?: GuruDetailsWhereInput | null
  }

  export type MuridDetailsRelationFilter = {
    is?: MuridDetailsWhereInput | null
    isNot?: MuridDetailsWhereInput | null
  }

  export type ParentDetailsRelationFilter = {
    is?: ParentDetailsWhereInput | null
    isNot?: ParentDetailsWhereInput | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type RolesListRelationFilter = {
    every?: RolesWhereInput
    some?: RolesWhereInput
    none?: RolesWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type RolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deleted?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type EnumJenisKelaminFilter = {
    equals?: JenisKelamin
    in?: Enumerable<JenisKelamin>
    notIn?: Enumerable<JenisKelamin>
    not?: NestedEnumJenisKelaminFilter | JenisKelamin
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type GuruCountOrderByAggregateInput = {
    id?: SortOrder
    nig?: SortOrder
    nigs?: SortOrder
    kodeGuru?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    tanggalMasuk?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type GuruAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GuruMaxOrderByAggregateInput = {
    id?: SortOrder
    nig?: SortOrder
    nigs?: SortOrder
    kodeGuru?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    tanggalMasuk?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type GuruMinOrderByAggregateInput = {
    id?: SortOrder
    nig?: SortOrder
    nigs?: SortOrder
    kodeGuru?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    tanggalMasuk?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type GuruSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumJenisKelaminWithAggregatesFilter = {
    equals?: JenisKelamin
    in?: Enumerable<JenisKelamin>
    notIn?: Enumerable<JenisKelamin>
    not?: NestedEnumJenisKelaminWithAggregatesFilter | JenisKelamin
    _count?: NestedIntFilter
    _min?: NestedEnumJenisKelaminFilter
    _max?: NestedEnumJenisKelaminFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type GuruRelationFilter = {
    is?: GuruWhereInput
    isNot?: GuruWhereInput
  }

  export type GuruTahfidzDetailsRelationFilter = {
    is?: GuruTahfidzDetailsWhereInput
    isNot?: GuruTahfidzDetailsWhereInput
  }

  export type GuruDetailsCountOrderByAggregateInput = {
    guruId?: SortOrder
    userId?: SortOrder
  }

  export type GuruDetailsAvgOrderByAggregateInput = {
    guruId?: SortOrder
    userId?: SortOrder
  }

  export type GuruDetailsMaxOrderByAggregateInput = {
    guruId?: SortOrder
    userId?: SortOrder
  }

  export type GuruDetailsMinOrderByAggregateInput = {
    guruId?: SortOrder
    userId?: SortOrder
  }

  export type GuruDetailsSumOrderByAggregateInput = {
    guruId?: SortOrder
    userId?: SortOrder
  }

  export type HalaqohListRelationFilter = {
    every?: HalaqohWhereInput
    some?: HalaqohWhereInput
    none?: HalaqohWhereInput
  }

  export type HalaqohOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuruTahfidzDetailsCountOrderByAggregateInput = {
    guruId?: SortOrder
    deleted?: SortOrder
  }

  export type GuruTahfidzDetailsAvgOrderByAggregateInput = {
    guruId?: SortOrder
  }

  export type GuruTahfidzDetailsMaxOrderByAggregateInput = {
    guruId?: SortOrder
    deleted?: SortOrder
  }

  export type GuruTahfidzDetailsMinOrderByAggregateInput = {
    guruId?: SortOrder
    deleted?: SortOrder
  }

  export type GuruTahfidzDetailsSumOrderByAggregateInput = {
    guruId?: SortOrder
  }

  export type EnumGolonganDarahNullableFilter = {
    equals?: GolonganDarah | null
    in?: Enumerable<GolonganDarah> | null
    notIn?: Enumerable<GolonganDarah> | null
    not?: NestedEnumGolonganDarahNullableFilter | GolonganDarah | null
  }

  export type ParentListRelationFilter = {
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
  }

  export type ParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuridCountOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    nism?: SortOrder
    nisn?: SortOrder
    nama?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
    golonganDarah?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type MuridAvgOrderByAggregateInput = {
    id?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
  }

  export type MuridMaxOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    nism?: SortOrder
    nisn?: SortOrder
    nama?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
    golonganDarah?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type MuridMinOrderByAggregateInput = {
    id?: SortOrder
    nis?: SortOrder
    nism?: SortOrder
    nisn?: SortOrder
    nama?: SortOrder
    jenisKelamin?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
    golonganDarah?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type MuridSumOrderByAggregateInput = {
    id?: SortOrder
    anakKe?: SortOrder
    jumlahSaudaraKandung?: SortOrder
    jumlahSaudaraTiri?: SortOrder
    jumlahSaudaraAngkat?: SortOrder
  }

  export type EnumGolonganDarahNullableWithAggregatesFilter = {
    equals?: GolonganDarah | null
    in?: Enumerable<GolonganDarah> | null
    notIn?: Enumerable<GolonganDarah> | null
    not?: NestedEnumGolonganDarahNullableWithAggregatesFilter | GolonganDarah | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGolonganDarahNullableFilter
    _max?: NestedEnumGolonganDarahNullableFilter
  }

  export type MuridRelationFilter = {
    is?: MuridWhereInput
    isNot?: MuridWhereInput
  }

  export type MuridTahfidzDetailsRelationFilter = {
    is?: MuridTahfidzDetailsWhereInput | null
    isNot?: MuridTahfidzDetailsWhereInput | null
  }

  export type MuridDetailsCountOrderByAggregateInput = {
    muridId?: SortOrder
    userId?: SortOrder
  }

  export type MuridDetailsAvgOrderByAggregateInput = {
    muridId?: SortOrder
    userId?: SortOrder
  }

  export type MuridDetailsMaxOrderByAggregateInput = {
    muridId?: SortOrder
    userId?: SortOrder
  }

  export type MuridDetailsMinOrderByAggregateInput = {
    muridId?: SortOrder
    userId?: SortOrder
  }

  export type MuridDetailsSumOrderByAggregateInput = {
    muridId?: SortOrder
    userId?: SortOrder
  }

  export type HalaqohRelationFilter = {
    is?: HalaqohWhereInput
    isNot?: HalaqohWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuridTahfidzDetailsCountOrderByAggregateInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
  }

  export type MuridTahfidzDetailsAvgOrderByAggregateInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
  }

  export type MuridTahfidzDetailsMaxOrderByAggregateInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
  }

  export type MuridTahfidzDetailsMinOrderByAggregateInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
  }

  export type MuridTahfidzDetailsSumOrderByAggregateInput = {
    muridId?: SortOrder
    kelompokTahfidzId?: SortOrder
  }

  export type EnumAgamaFilter = {
    equals?: Agama
    in?: Enumerable<Agama>
    notIn?: Enumerable<Agama>
    not?: NestedEnumAgamaFilter | Agama
  }

  export type EnumPendidikanFilter = {
    equals?: Pendidikan
    in?: Enumerable<Pendidikan>
    notIn?: Enumerable<Pendidikan>
    not?: NestedEnumPendidikanFilter | Pendidikan
  }

  export type EnumHidupFilter = {
    equals?: Hidup
    in?: Enumerable<Hidup>
    notIn?: Enumerable<Hidup>
    not?: NestedEnumHidupFilter | Hidup
  }

  export type MuridListRelationFilter = {
    every?: MuridWhereInput
    some?: MuridWhereInput
    none?: MuridWhereInput
  }

  export type MuridOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    agama?: SortOrder
    pendidikanTerakhir?: SortOrder
    penghasilanPerBulan?: SortOrder
    pekerjaan?: SortOrder
    nomorTelepon?: SortOrder
    statusHidup?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type ParentAvgOrderByAggregateInput = {
    id?: SortOrder
    penghasilanPerBulan?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    agama?: SortOrder
    pendidikanTerakhir?: SortOrder
    penghasilanPerBulan?: SortOrder
    pekerjaan?: SortOrder
    nomorTelepon?: SortOrder
    statusHidup?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    tempatLahir?: SortOrder
    tanggalLahir?: SortOrder
    jenisKelamin?: SortOrder
    agama?: SortOrder
    pendidikanTerakhir?: SortOrder
    penghasilanPerBulan?: SortOrder
    pekerjaan?: SortOrder
    nomorTelepon?: SortOrder
    statusHidup?: SortOrder
    profileUrl?: SortOrder
    deleted?: SortOrder
  }

  export type ParentSumOrderByAggregateInput = {
    id?: SortOrder
    penghasilanPerBulan?: SortOrder
  }

  export type EnumAgamaWithAggregatesFilter = {
    equals?: Agama
    in?: Enumerable<Agama>
    notIn?: Enumerable<Agama>
    not?: NestedEnumAgamaWithAggregatesFilter | Agama
    _count?: NestedIntFilter
    _min?: NestedEnumAgamaFilter
    _max?: NestedEnumAgamaFilter
  }

  export type EnumPendidikanWithAggregatesFilter = {
    equals?: Pendidikan
    in?: Enumerable<Pendidikan>
    notIn?: Enumerable<Pendidikan>
    not?: NestedEnumPendidikanWithAggregatesFilter | Pendidikan
    _count?: NestedIntFilter
    _min?: NestedEnumPendidikanFilter
    _max?: NestedEnumPendidikanFilter
  }

  export type EnumHidupWithAggregatesFilter = {
    equals?: Hidup
    in?: Enumerable<Hidup>
    notIn?: Enumerable<Hidup>
    not?: NestedEnumHidupWithAggregatesFilter | Hidup
    _count?: NestedIntFilter
    _min?: NestedEnumHidupFilter
    _max?: NestedEnumHidupFilter
  }

  export type ParentRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type ParentDetailsCountOrderByAggregateInput = {
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type ParentDetailsAvgOrderByAggregateInput = {
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type ParentDetailsMaxOrderByAggregateInput = {
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type ParentDetailsMinOrderByAggregateInput = {
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type ParentDetailsSumOrderByAggregateInput = {
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type EnumTipeEventFilter = {
    equals?: TipeEvent
    in?: Enumerable<TipeEvent>
    notIn?: Enumerable<TipeEvent>
    not?: NestedEnumTipeEventFilter | TipeEvent
  }

  export type EnumEventModelTypeFilter = {
    equals?: EventModelType
    in?: Enumerable<EventModelType>
    notIn?: Enumerable<EventModelType>
    not?: NestedEnumEventModelTypeFilter | EventModelType
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
    time?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
    targetId?: SortOrder
    userId?: SortOrder
  }

  export type EnumTipeEventWithAggregatesFilter = {
    equals?: TipeEvent
    in?: Enumerable<TipeEvent>
    notIn?: Enumerable<TipeEvent>
    not?: NestedEnumTipeEventWithAggregatesFilter | TipeEvent
    _count?: NestedIntFilter
    _min?: NestedEnumTipeEventFilter
    _max?: NestedEnumTipeEventFilter
  }

  export type EnumEventModelTypeWithAggregatesFilter = {
    equals?: EventModelType
    in?: Enumerable<EventModelType>
    notIn?: Enumerable<EventModelType>
    not?: NestedEnumEventModelTypeWithAggregatesFilter | EventModelType
    _count?: NestedIntFilter
    _min?: NestedEnumEventModelTypeFilter
    _max?: NestedEnumEventModelTypeFilter
  }

  export type MuridTahfidzDetailsListRelationFilter = {
    every?: MuridTahfidzDetailsWhereInput
    some?: MuridTahfidzDetailsWhereInput
    none?: MuridTahfidzDetailsWhereInput
  }

  export type MuridTahfidzDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HalaqohCountOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    guruId?: SortOrder
  }

  export type HalaqohAvgOrderByAggregateInput = {
    id?: SortOrder
    guruId?: SortOrder
  }

  export type HalaqohMaxOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    guruId?: SortOrder
  }

  export type HalaqohMinOrderByAggregateInput = {
    id?: SortOrder
    kode?: SortOrder
    guruId?: SortOrder
  }

  export type HalaqohSumOrderByAggregateInput = {
    id?: SortOrder
    guruId?: SortOrder
  }

  export type EnumTipeSesiFilter = {
    equals?: TipeSesi
    in?: Enumerable<TipeSesi>
    notIn?: Enumerable<TipeSesi>
    not?: NestedEnumTipeSesiFilter | TipeSesi
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    awalSetoran?: SortOrder
    akhirSetoran?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    jamTahfidz?: SortOrder
    muridId?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    muridId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    awalSetoran?: SortOrder
    akhirSetoran?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    jamTahfidz?: SortOrder
    muridId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    waktu?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    awalSetoran?: SortOrder
    akhirSetoran?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    jamTahfidz?: SortOrder
    muridId?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    juz?: SortOrder
    halaman?: SortOrder
    nilaiTajwid?: SortOrder
    nilaiKelancaran?: SortOrder
    nilaiMakhroj?: SortOrder
    nilaiSifatHuruf?: SortOrder
    muridId?: SortOrder
  }

  export type EnumTipeSesiWithAggregatesFilter = {
    equals?: TipeSesi
    in?: Enumerable<TipeSesi>
    notIn?: Enumerable<TipeSesi>
    not?: NestedEnumTipeSesiWithAggregatesFilter | TipeSesi
    _count?: NestedIntFilter
    _min?: NestedEnumTipeSesiFilter
    _max?: NestedEnumTipeSesiFilter
  }

  export type JamTahfidzCountOrderByAggregateInput = {
    id?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    namaJam?: SortOrder
    tipe?: SortOrder
  }

  export type JamTahfidzAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JamTahfidzMaxOrderByAggregateInput = {
    id?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    namaJam?: SortOrder
    tipe?: SortOrder
  }

  export type JamTahfidzMinOrderByAggregateInput = {
    id?: SortOrder
    waktuMulai?: SortOrder
    waktuSelesai?: SortOrder
    namaJam?: SortOrder
    tipe?: SortOrder
  }

  export type JamTahfidzSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlQuranCountOrderByAggregateInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
    deleted?: SortOrder
  }

  export type AlQuranAvgOrderByAggregateInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
  }

  export type AlQuranMaxOrderByAggregateInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
    deleted?: SortOrder
  }

  export type AlQuranMinOrderByAggregateInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
    deleted?: SortOrder
  }

  export type AlQuranSumOrderByAggregateInput = {
    id?: SortOrder
    ayat?: SortOrder
    baris?: SortOrder
    halaman?: SortOrder
    surah?: SortOrder
    juz?: SortOrder
  }

  export type GuruDetailsCreateNestedOneWithoutUserInput = {
    create?: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutUserInput
    connect?: GuruDetailsWhereUniqueInput
  }

  export type MuridDetailsCreateNestedOneWithoutUserInput = {
    create?: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutUserInput
    connect?: MuridDetailsWhereUniqueInput
  }

  export type ParentDetailsCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutUserInput
    connect?: ParentDetailsWhereUniqueInput
  }

  export type RolesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RolesCreateWithoutUserInput>, Enumerable<RolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RolesCreateOrConnectWithoutUserInput>
    createMany?: RolesCreateManyUserInputEnvelope
    connect?: Enumerable<RolesWhereUniqueInput>
  }

  export type EventCreateNestedManyWithoutActorInput = {
    create?: XOR<Enumerable<EventCreateWithoutActorInput>, Enumerable<EventUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutActorInput>
    createMany?: EventCreateManyActorInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type GuruDetailsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutUserInput
    connect?: GuruDetailsWhereUniqueInput
  }

  export type MuridDetailsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutUserInput
    connect?: MuridDetailsWhereUniqueInput
  }

  export type ParentDetailsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutUserInput
    connect?: ParentDetailsWhereUniqueInput
  }

  export type RolesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<RolesCreateWithoutUserInput>, Enumerable<RolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RolesCreateOrConnectWithoutUserInput>
    createMany?: RolesCreateManyUserInputEnvelope
    connect?: Enumerable<RolesWhereUniqueInput>
  }

  export type EventUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<Enumerable<EventCreateWithoutActorInput>, Enumerable<EventUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutActorInput>
    createMany?: EventCreateManyActorInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type GuruDetailsUpdateOneWithoutUserInput = {
    create?: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutUserInput
    upsert?: GuruDetailsUpsertWithoutUserInput
    connect?: GuruDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruDetailsUpdateWithoutUserInput, GuruDetailsUncheckedUpdateWithoutUserInput>
  }

  export type MuridDetailsUpdateOneWithoutUserInput = {
    create?: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutUserInput
    upsert?: MuridDetailsUpsertWithoutUserInput
    connect?: MuridDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridDetailsUpdateWithoutUserInput, MuridDetailsUncheckedUpdateWithoutUserInput>
  }

  export type ParentDetailsUpdateOneWithoutUserInput = {
    create?: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutUserInput
    upsert?: ParentDetailsUpsertWithoutUserInput
    connect?: ParentDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ParentDetailsUpdateWithoutUserInput, ParentDetailsUncheckedUpdateWithoutUserInput>
  }

  export type RolesUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RolesCreateWithoutUserInput>, Enumerable<RolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RolesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RolesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RolesCreateManyUserInputEnvelope
    connect?: Enumerable<RolesWhereUniqueInput>
    set?: Enumerable<RolesWhereUniqueInput>
    disconnect?: Enumerable<RolesWhereUniqueInput>
    delete?: Enumerable<RolesWhereUniqueInput>
    update?: Enumerable<RolesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RolesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RolesScalarWhereInput>
  }

  export type EventUpdateManyWithoutActorInput = {
    create?: XOR<Enumerable<EventCreateWithoutActorInput>, Enumerable<EventUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutActorInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutActorInput>
    createMany?: EventCreateManyActorInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutActorInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutActorInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type GuruDetailsUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutUserInput
    upsert?: GuruDetailsUpsertWithoutUserInput
    connect?: GuruDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruDetailsUpdateWithoutUserInput, GuruDetailsUncheckedUpdateWithoutUserInput>
  }

  export type MuridDetailsUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutUserInput
    upsert?: MuridDetailsUpsertWithoutUserInput
    connect?: MuridDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridDetailsUpdateWithoutUserInput, MuridDetailsUncheckedUpdateWithoutUserInput>
  }

  export type ParentDetailsUncheckedUpdateOneWithoutUserInput = {
    create?: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutUserInput
    upsert?: ParentDetailsUpsertWithoutUserInput
    connect?: ParentDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ParentDetailsUpdateWithoutUserInput, ParentDetailsUncheckedUpdateWithoutUserInput>
  }

  export type RolesUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<RolesCreateWithoutUserInput>, Enumerable<RolesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<RolesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<RolesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: RolesCreateManyUserInputEnvelope
    connect?: Enumerable<RolesWhereUniqueInput>
    set?: Enumerable<RolesWhereUniqueInput>
    disconnect?: Enumerable<RolesWhereUniqueInput>
    delete?: Enumerable<RolesWhereUniqueInput>
    update?: Enumerable<RolesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<RolesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<RolesScalarWhereInput>
  }

  export type EventUncheckedUpdateManyWithoutActorInput = {
    create?: XOR<Enumerable<EventCreateWithoutActorInput>, Enumerable<EventUncheckedCreateWithoutActorInput>>
    connectOrCreate?: Enumerable<EventCreateOrConnectWithoutActorInput>
    upsert?: Enumerable<EventUpsertWithWhereUniqueWithoutActorInput>
    createMany?: EventCreateManyActorInputEnvelope
    connect?: Enumerable<EventWhereUniqueInput>
    set?: Enumerable<EventWhereUniqueInput>
    disconnect?: Enumerable<EventWhereUniqueInput>
    delete?: Enumerable<EventWhereUniqueInput>
    update?: Enumerable<EventUpdateWithWhereUniqueWithoutActorInput>
    updateMany?: Enumerable<EventUpdateManyWithWhereWithoutActorInput>
    deleteMany?: Enumerable<EventScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type UserUpdateOneRequiredWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type GuruDetailsCreateNestedOneWithoutGuruInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruInput
    connect?: GuruDetailsWhereUniqueInput
  }

  export type GuruDetailsUncheckedCreateNestedOneWithoutGuruInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruInput
    connect?: GuruDetailsWhereUniqueInput
  }

  export type EnumJenisKelaminFieldUpdateOperationsInput = {
    set?: JenisKelamin
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type GuruDetailsUpdateOneWithoutGuruInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruInput
    upsert?: GuruDetailsUpsertWithoutGuruInput
    connect?: GuruDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruDetailsUpdateWithoutGuruInput, GuruDetailsUncheckedUpdateWithoutGuruInput>
  }

  export type GuruDetailsUncheckedUpdateOneWithoutGuruInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruInput
    upsert?: GuruDetailsUpsertWithoutGuruInput
    connect?: GuruDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruDetailsUpdateWithoutGuruInput, GuruDetailsUncheckedUpdateWithoutGuruInput>
  }

  export type GuruCreateNestedOneWithoutGuruDetailsInput = {
    create?: XOR<GuruCreateWithoutGuruDetailsInput, GuruUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruCreateOrConnectWithoutGuruDetailsInput
    connect?: GuruWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIsGuruInput = {
    create?: XOR<UserCreateWithoutIsGuruInput, UserUncheckedCreateWithoutIsGuruInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsGuruInput
    connect?: UserWhereUniqueInput
  }

  export type GuruTahfidzDetailsCreateNestedOneWithoutGuruDetailsInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutGuruDetailsInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
  }

  export type GuruTahfidzDetailsUncheckedCreateNestedOneWithoutGuruDetailsInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutGuruDetailsInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
  }

  export type GuruUpdateOneRequiredWithoutGuruDetailsInput = {
    create?: XOR<GuruCreateWithoutGuruDetailsInput, GuruUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruCreateOrConnectWithoutGuruDetailsInput
    upsert?: GuruUpsertWithoutGuruDetailsInput
    connect?: GuruWhereUniqueInput
    update?: XOR<GuruUpdateWithoutGuruDetailsInput, GuruUncheckedUpdateWithoutGuruDetailsInput>
  }

  export type UserUpdateOneRequiredWithoutIsGuruInput = {
    create?: XOR<UserCreateWithoutIsGuruInput, UserUncheckedCreateWithoutIsGuruInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsGuruInput
    upsert?: UserUpsertWithoutIsGuruInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIsGuruInput, UserUncheckedUpdateWithoutIsGuruInput>
  }

  export type GuruTahfidzDetailsUpdateOneWithoutGuruDetailsInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutGuruDetailsInput
    upsert?: GuruTahfidzDetailsUpsertWithoutGuruDetailsInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruTahfidzDetailsUpdateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedUpdateWithoutGuruDetailsInput>
  }

  export type GuruTahfidzDetailsUncheckedUpdateOneWithoutGuruDetailsInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutGuruDetailsInput
    upsert?: GuruTahfidzDetailsUpsertWithoutGuruDetailsInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<GuruTahfidzDetailsUpdateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedUpdateWithoutGuruDetailsInput>
  }

  export type GuruDetailsCreateNestedOneWithoutGuruTahfidzDetailInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedCreateWithoutGuruTahfidzDetailInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruTahfidzDetailInput
    connect?: GuruDetailsWhereUniqueInput
  }

  export type HalaqohCreateNestedManyWithoutGuruTahfidzDetailInput = {
    create?: XOR<Enumerable<HalaqohCreateWithoutGuruTahfidzDetailInput>, Enumerable<HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>>
    connectOrCreate?: Enumerable<HalaqohCreateOrConnectWithoutGuruTahfidzDetailInput>
    createMany?: HalaqohCreateManyGuruTahfidzDetailInputEnvelope
    connect?: Enumerable<HalaqohWhereUniqueInput>
  }

  export type HalaqohUncheckedCreateNestedManyWithoutGuruTahfidzDetailInput = {
    create?: XOR<Enumerable<HalaqohCreateWithoutGuruTahfidzDetailInput>, Enumerable<HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>>
    connectOrCreate?: Enumerable<HalaqohCreateOrConnectWithoutGuruTahfidzDetailInput>
    createMany?: HalaqohCreateManyGuruTahfidzDetailInputEnvelope
    connect?: Enumerable<HalaqohWhereUniqueInput>
  }

  export type GuruDetailsUpdateOneRequiredWithoutGuruTahfidzDetailInput = {
    create?: XOR<GuruDetailsCreateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedCreateWithoutGuruTahfidzDetailInput>
    connectOrCreate?: GuruDetailsCreateOrConnectWithoutGuruTahfidzDetailInput
    upsert?: GuruDetailsUpsertWithoutGuruTahfidzDetailInput
    connect?: GuruDetailsWhereUniqueInput
    update?: XOR<GuruDetailsUpdateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedUpdateWithoutGuruTahfidzDetailInput>
  }

  export type HalaqohUpdateManyWithoutGuruTahfidzDetailInput = {
    create?: XOR<Enumerable<HalaqohCreateWithoutGuruTahfidzDetailInput>, Enumerable<HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>>
    connectOrCreate?: Enumerable<HalaqohCreateOrConnectWithoutGuruTahfidzDetailInput>
    upsert?: Enumerable<HalaqohUpsertWithWhereUniqueWithoutGuruTahfidzDetailInput>
    createMany?: HalaqohCreateManyGuruTahfidzDetailInputEnvelope
    connect?: Enumerable<HalaqohWhereUniqueInput>
    set?: Enumerable<HalaqohWhereUniqueInput>
    disconnect?: Enumerable<HalaqohWhereUniqueInput>
    delete?: Enumerable<HalaqohWhereUniqueInput>
    update?: Enumerable<HalaqohUpdateWithWhereUniqueWithoutGuruTahfidzDetailInput>
    updateMany?: Enumerable<HalaqohUpdateManyWithWhereWithoutGuruTahfidzDetailInput>
    deleteMany?: Enumerable<HalaqohScalarWhereInput>
  }

  export type HalaqohUncheckedUpdateManyWithoutGuruTahfidzDetailInput = {
    create?: XOR<Enumerable<HalaqohCreateWithoutGuruTahfidzDetailInput>, Enumerable<HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>>
    connectOrCreate?: Enumerable<HalaqohCreateOrConnectWithoutGuruTahfidzDetailInput>
    upsert?: Enumerable<HalaqohUpsertWithWhereUniqueWithoutGuruTahfidzDetailInput>
    createMany?: HalaqohCreateManyGuruTahfidzDetailInputEnvelope
    connect?: Enumerable<HalaqohWhereUniqueInput>
    set?: Enumerable<HalaqohWhereUniqueInput>
    disconnect?: Enumerable<HalaqohWhereUniqueInput>
    delete?: Enumerable<HalaqohWhereUniqueInput>
    update?: Enumerable<HalaqohUpdateWithWhereUniqueWithoutGuruTahfidzDetailInput>
    updateMany?: Enumerable<HalaqohUpdateManyWithWhereWithoutGuruTahfidzDetailInput>
    deleteMany?: Enumerable<HalaqohScalarWhereInput>
  }

  export type MuridDetailsCreateNestedOneWithoutMuridInput = {
    create?: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutMuridInput
    connect?: MuridDetailsWhereUniqueInput
  }

  export type ParentCreateNestedManyWithoutDaftarAnakInput = {
    create?: XOR<Enumerable<ParentCreateWithoutDaftarAnakInput>, Enumerable<ParentUncheckedCreateWithoutDaftarAnakInput>>
    connectOrCreate?: Enumerable<ParentCreateOrConnectWithoutDaftarAnakInput>
    connect?: Enumerable<ParentWhereUniqueInput>
  }

  export type MuridDetailsUncheckedCreateNestedOneWithoutMuridInput = {
    create?: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutMuridInput
    connect?: MuridDetailsWhereUniqueInput
  }

  export type NullableEnumGolonganDarahFieldUpdateOperationsInput = {
    set?: GolonganDarah | null
  }

  export type MuridDetailsUpdateOneWithoutMuridInput = {
    create?: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutMuridInput
    upsert?: MuridDetailsUpsertWithoutMuridInput
    connect?: MuridDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridDetailsUpdateWithoutMuridInput, MuridDetailsUncheckedUpdateWithoutMuridInput>
  }

  export type ParentUpdateManyWithoutDaftarAnakInput = {
    create?: XOR<Enumerable<ParentCreateWithoutDaftarAnakInput>, Enumerable<ParentUncheckedCreateWithoutDaftarAnakInput>>
    connectOrCreate?: Enumerable<ParentCreateOrConnectWithoutDaftarAnakInput>
    upsert?: Enumerable<ParentUpsertWithWhereUniqueWithoutDaftarAnakInput>
    connect?: Enumerable<ParentWhereUniqueInput>
    set?: Enumerable<ParentWhereUniqueInput>
    disconnect?: Enumerable<ParentWhereUniqueInput>
    delete?: Enumerable<ParentWhereUniqueInput>
    update?: Enumerable<ParentUpdateWithWhereUniqueWithoutDaftarAnakInput>
    updateMany?: Enumerable<ParentUpdateManyWithWhereWithoutDaftarAnakInput>
    deleteMany?: Enumerable<ParentScalarWhereInput>
  }

  export type MuridDetailsUncheckedUpdateOneWithoutMuridInput = {
    create?: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutMuridInput
    upsert?: MuridDetailsUpsertWithoutMuridInput
    connect?: MuridDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridDetailsUpdateWithoutMuridInput, MuridDetailsUncheckedUpdateWithoutMuridInput>
  }

  export type MuridCreateNestedOneWithoutMuridDetailsInput = {
    create?: XOR<MuridCreateWithoutMuridDetailsInput, MuridUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridCreateOrConnectWithoutMuridDetailsInput
    connect?: MuridWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIsMuridInput = {
    create?: XOR<UserCreateWithoutIsMuridInput, UserUncheckedCreateWithoutIsMuridInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsMuridInput
    connect?: UserWhereUniqueInput
  }

  export type MuridTahfidzDetailsCreateNestedOneWithoutMuridDetailsInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutMuridDetailsInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
  }

  export type MuridTahfidzDetailsUncheckedCreateNestedOneWithoutMuridDetailsInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutMuridDetailsInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
  }

  export type MuridUpdateOneRequiredWithoutMuridDetailsInput = {
    create?: XOR<MuridCreateWithoutMuridDetailsInput, MuridUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridCreateOrConnectWithoutMuridDetailsInput
    upsert?: MuridUpsertWithoutMuridDetailsInput
    connect?: MuridWhereUniqueInput
    update?: XOR<MuridUpdateWithoutMuridDetailsInput, MuridUncheckedUpdateWithoutMuridDetailsInput>
  }

  export type UserUpdateOneRequiredWithoutIsMuridInput = {
    create?: XOR<UserCreateWithoutIsMuridInput, UserUncheckedCreateWithoutIsMuridInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsMuridInput
    upsert?: UserUpsertWithoutIsMuridInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIsMuridInput, UserUncheckedUpdateWithoutIsMuridInput>
  }

  export type MuridTahfidzDetailsUpdateOneWithoutMuridDetailsInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutMuridDetailsInput
    upsert?: MuridTahfidzDetailsUpsertWithoutMuridDetailsInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridTahfidzDetailsUpdateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedUpdateWithoutMuridDetailsInput>
  }

  export type MuridTahfidzDetailsUncheckedUpdateOneWithoutMuridDetailsInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutMuridDetailsInput
    upsert?: MuridTahfidzDetailsUpsertWithoutMuridDetailsInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MuridTahfidzDetailsUpdateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedUpdateWithoutMuridDetailsInput>
  }

  export type MuridDetailsCreateNestedOneWithoutTahfidzDetailsInput = {
    create?: XOR<MuridDetailsCreateWithoutTahfidzDetailsInput, MuridDetailsUncheckedCreateWithoutTahfidzDetailsInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutTahfidzDetailsInput
    connect?: MuridDetailsWhereUniqueInput
  }

  export type HalaqohCreateNestedOneWithoutMuridTahfidzDetailInput = {
    create?: XOR<HalaqohCreateWithoutMuridTahfidzDetailInput, HalaqohUncheckedCreateWithoutMuridTahfidzDetailInput>
    connectOrCreate?: HalaqohCreateOrConnectWithoutMuridTahfidzDetailInput
    connect?: HalaqohWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutMuridTahfidzDetailInput = {
    create?: XOR<Enumerable<SessionCreateWithoutMuridTahfidzDetailInput>, Enumerable<SessionUncheckedCreateWithoutMuridTahfidzDetailInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutMuridTahfidzDetailInput>
    createMany?: SessionCreateManyMuridTahfidzDetailInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type SessionUncheckedCreateNestedManyWithoutMuridTahfidzDetailInput = {
    create?: XOR<Enumerable<SessionCreateWithoutMuridTahfidzDetailInput>, Enumerable<SessionUncheckedCreateWithoutMuridTahfidzDetailInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutMuridTahfidzDetailInput>
    createMany?: SessionCreateManyMuridTahfidzDetailInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
  }

  export type MuridDetailsUpdateOneRequiredWithoutTahfidzDetailsInput = {
    create?: XOR<MuridDetailsCreateWithoutTahfidzDetailsInput, MuridDetailsUncheckedCreateWithoutTahfidzDetailsInput>
    connectOrCreate?: MuridDetailsCreateOrConnectWithoutTahfidzDetailsInput
    upsert?: MuridDetailsUpsertWithoutTahfidzDetailsInput
    connect?: MuridDetailsWhereUniqueInput
    update?: XOR<MuridDetailsUpdateWithoutTahfidzDetailsInput, MuridDetailsUncheckedUpdateWithoutTahfidzDetailsInput>
  }

  export type HalaqohUpdateOneRequiredWithoutMuridTahfidzDetailInput = {
    create?: XOR<HalaqohCreateWithoutMuridTahfidzDetailInput, HalaqohUncheckedCreateWithoutMuridTahfidzDetailInput>
    connectOrCreate?: HalaqohCreateOrConnectWithoutMuridTahfidzDetailInput
    upsert?: HalaqohUpsertWithoutMuridTahfidzDetailInput
    connect?: HalaqohWhereUniqueInput
    update?: XOR<HalaqohUpdateWithoutMuridTahfidzDetailInput, HalaqohUncheckedUpdateWithoutMuridTahfidzDetailInput>
  }

  export type SessionUpdateManyWithoutMuridTahfidzDetailInput = {
    create?: XOR<Enumerable<SessionCreateWithoutMuridTahfidzDetailInput>, Enumerable<SessionUncheckedCreateWithoutMuridTahfidzDetailInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutMuridTahfidzDetailInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutMuridTahfidzDetailInput>
    createMany?: SessionCreateManyMuridTahfidzDetailInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutMuridTahfidzDetailInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutMuridTahfidzDetailInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type SessionUncheckedUpdateManyWithoutMuridTahfidzDetailInput = {
    create?: XOR<Enumerable<SessionCreateWithoutMuridTahfidzDetailInput>, Enumerable<SessionUncheckedCreateWithoutMuridTahfidzDetailInput>>
    connectOrCreate?: Enumerable<SessionCreateOrConnectWithoutMuridTahfidzDetailInput>
    upsert?: Enumerable<SessionUpsertWithWhereUniqueWithoutMuridTahfidzDetailInput>
    createMany?: SessionCreateManyMuridTahfidzDetailInputEnvelope
    connect?: Enumerable<SessionWhereUniqueInput>
    set?: Enumerable<SessionWhereUniqueInput>
    disconnect?: Enumerable<SessionWhereUniqueInput>
    delete?: Enumerable<SessionWhereUniqueInput>
    update?: Enumerable<SessionUpdateWithWhereUniqueWithoutMuridTahfidzDetailInput>
    updateMany?: Enumerable<SessionUpdateManyWithWhereWithoutMuridTahfidzDetailInput>
    deleteMany?: Enumerable<SessionScalarWhereInput>
  }

  export type ParentDetailsCreateNestedOneWithoutParentInput = {
    create?: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutParentInput
    connect?: ParentDetailsWhereUniqueInput
  }

  export type MuridCreateNestedManyWithoutOrangTuaInput = {
    create?: XOR<Enumerable<MuridCreateWithoutOrangTuaInput>, Enumerable<MuridUncheckedCreateWithoutOrangTuaInput>>
    connectOrCreate?: Enumerable<MuridCreateOrConnectWithoutOrangTuaInput>
    connect?: Enumerable<MuridWhereUniqueInput>
  }

  export type ParentDetailsUncheckedCreateNestedOneWithoutParentInput = {
    create?: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutParentInput
    connect?: ParentDetailsWhereUniqueInput
  }

  export type EnumAgamaFieldUpdateOperationsInput = {
    set?: Agama
  }

  export type EnumPendidikanFieldUpdateOperationsInput = {
    set?: Pendidikan
  }

  export type EnumHidupFieldUpdateOperationsInput = {
    set?: Hidup
  }

  export type ParentDetailsUpdateOneWithoutParentInput = {
    create?: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutParentInput
    upsert?: ParentDetailsUpsertWithoutParentInput
    connect?: ParentDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ParentDetailsUpdateWithoutParentInput, ParentDetailsUncheckedUpdateWithoutParentInput>
  }

  export type MuridUpdateManyWithoutOrangTuaInput = {
    create?: XOR<Enumerable<MuridCreateWithoutOrangTuaInput>, Enumerable<MuridUncheckedCreateWithoutOrangTuaInput>>
    connectOrCreate?: Enumerable<MuridCreateOrConnectWithoutOrangTuaInput>
    upsert?: Enumerable<MuridUpsertWithWhereUniqueWithoutOrangTuaInput>
    connect?: Enumerable<MuridWhereUniqueInput>
    set?: Enumerable<MuridWhereUniqueInput>
    disconnect?: Enumerable<MuridWhereUniqueInput>
    delete?: Enumerable<MuridWhereUniqueInput>
    update?: Enumerable<MuridUpdateWithWhereUniqueWithoutOrangTuaInput>
    updateMany?: Enumerable<MuridUpdateManyWithWhereWithoutOrangTuaInput>
    deleteMany?: Enumerable<MuridScalarWhereInput>
  }

  export type ParentDetailsUncheckedUpdateOneWithoutParentInput = {
    create?: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
    connectOrCreate?: ParentDetailsCreateOrConnectWithoutParentInput
    upsert?: ParentDetailsUpsertWithoutParentInput
    connect?: ParentDetailsWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ParentDetailsUpdateWithoutParentInput, ParentDetailsUncheckedUpdateWithoutParentInput>
  }

  export type ParentCreateNestedOneWithoutParentDetailsInput = {
    create?: XOR<ParentCreateWithoutParentDetailsInput, ParentUncheckedCreateWithoutParentDetailsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutParentDetailsInput
    connect?: ParentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIsParentInput = {
    create?: XOR<UserCreateWithoutIsParentInput, UserUncheckedCreateWithoutIsParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsParentInput
    connect?: UserWhereUniqueInput
  }

  export type ParentUpdateOneRequiredWithoutParentDetailsInput = {
    create?: XOR<ParentCreateWithoutParentDetailsInput, ParentUncheckedCreateWithoutParentDetailsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutParentDetailsInput
    upsert?: ParentUpsertWithoutParentDetailsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<ParentUpdateWithoutParentDetailsInput, ParentUncheckedUpdateWithoutParentDetailsInput>
  }

  export type UserUpdateOneRequiredWithoutIsParentInput = {
    create?: XOR<UserCreateWithoutIsParentInput, UserUncheckedCreateWithoutIsParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutIsParentInput
    upsert?: UserUpsertWithoutIsParentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutIsParentInput, UserUncheckedUpdateWithoutIsParentInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTipeEventFieldUpdateOperationsInput = {
    set?: TipeEvent
  }

  export type EnumEventModelTypeFieldUpdateOperationsInput = {
    set?: EventModelType
  }

  export type UserUpdateOneRequiredWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type GuruTahfidzDetailsCreateNestedOneWithoutKelompokTahfidzInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
  }

  export type MuridTahfidzDetailsCreateNestedManyWithoutKelompokTahfidzInput = {
    create?: XOR<Enumerable<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput>, Enumerable<MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>>
    connectOrCreate?: Enumerable<MuridTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput>
    createMany?: MuridTahfidzDetailsCreateManyKelompokTahfidzInputEnvelope
    connect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
  }

  export type MuridTahfidzDetailsUncheckedCreateNestedManyWithoutKelompokTahfidzInput = {
    create?: XOR<Enumerable<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput>, Enumerable<MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>>
    connectOrCreate?: Enumerable<MuridTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput>
    createMany?: MuridTahfidzDetailsCreateManyKelompokTahfidzInputEnvelope
    connect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
  }

  export type GuruTahfidzDetailsUpdateOneRequiredWithoutKelompokTahfidzInput = {
    create?: XOR<GuruTahfidzDetailsCreateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
    connectOrCreate?: GuruTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput
    upsert?: GuruTahfidzDetailsUpsertWithoutKelompokTahfidzInput
    connect?: GuruTahfidzDetailsWhereUniqueInput
    update?: XOR<GuruTahfidzDetailsUpdateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput>
  }

  export type MuridTahfidzDetailsUpdateManyWithoutKelompokTahfidzInput = {
    create?: XOR<Enumerable<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput>, Enumerable<MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>>
    connectOrCreate?: Enumerable<MuridTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput>
    upsert?: Enumerable<MuridTahfidzDetailsUpsertWithWhereUniqueWithoutKelompokTahfidzInput>
    createMany?: MuridTahfidzDetailsCreateManyKelompokTahfidzInputEnvelope
    connect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    set?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    disconnect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    delete?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    update?: Enumerable<MuridTahfidzDetailsUpdateWithWhereUniqueWithoutKelompokTahfidzInput>
    updateMany?: Enumerable<MuridTahfidzDetailsUpdateManyWithWhereWithoutKelompokTahfidzInput>
    deleteMany?: Enumerable<MuridTahfidzDetailsScalarWhereInput>
  }

  export type MuridTahfidzDetailsUncheckedUpdateManyWithoutKelompokTahfidzInput = {
    create?: XOR<Enumerable<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput>, Enumerable<MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>>
    connectOrCreate?: Enumerable<MuridTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput>
    upsert?: Enumerable<MuridTahfidzDetailsUpsertWithWhereUniqueWithoutKelompokTahfidzInput>
    createMany?: MuridTahfidzDetailsCreateManyKelompokTahfidzInputEnvelope
    connect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    set?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    disconnect?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    delete?: Enumerable<MuridTahfidzDetailsWhereUniqueInput>
    update?: Enumerable<MuridTahfidzDetailsUpdateWithWhereUniqueWithoutKelompokTahfidzInput>
    updateMany?: Enumerable<MuridTahfidzDetailsUpdateManyWithWhereWithoutKelompokTahfidzInput>
    deleteMany?: Enumerable<MuridTahfidzDetailsScalarWhereInput>
  }

  export type MuridTahfidzDetailsCreateNestedOneWithoutSesiInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutSesiInput, MuridTahfidzDetailsUncheckedCreateWithoutSesiInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutSesiInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
  }

  export type EnumTipeSesiFieldUpdateOperationsInput = {
    set?: TipeSesi
  }

  export type MuridTahfidzDetailsUpdateOneRequiredWithoutSesiInput = {
    create?: XOR<MuridTahfidzDetailsCreateWithoutSesiInput, MuridTahfidzDetailsUncheckedCreateWithoutSesiInput>
    connectOrCreate?: MuridTahfidzDetailsCreateOrConnectWithoutSesiInput
    upsert?: MuridTahfidzDetailsUpsertWithoutSesiInput
    connect?: MuridTahfidzDetailsWhereUniqueInput
    update?: XOR<MuridTahfidzDetailsUpdateWithoutSesiInput, MuridTahfidzDetailsUncheckedUpdateWithoutSesiInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedEnumJenisKelaminFilter = {
    equals?: JenisKelamin
    in?: Enumerable<JenisKelamin>
    notIn?: Enumerable<JenisKelamin>
    not?: NestedEnumJenisKelaminFilter | JenisKelamin
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedEnumJenisKelaminWithAggregatesFilter = {
    equals?: JenisKelamin
    in?: Enumerable<JenisKelamin>
    notIn?: Enumerable<JenisKelamin>
    not?: NestedEnumJenisKelaminWithAggregatesFilter | JenisKelamin
    _count?: NestedIntFilter
    _min?: NestedEnumJenisKelaminFilter
    _max?: NestedEnumJenisKelaminFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumGolonganDarahNullableFilter = {
    equals?: GolonganDarah | null
    in?: Enumerable<GolonganDarah> | null
    notIn?: Enumerable<GolonganDarah> | null
    not?: NestedEnumGolonganDarahNullableFilter | GolonganDarah | null
  }

  export type NestedEnumGolonganDarahNullableWithAggregatesFilter = {
    equals?: GolonganDarah | null
    in?: Enumerable<GolonganDarah> | null
    notIn?: Enumerable<GolonganDarah> | null
    not?: NestedEnumGolonganDarahNullableWithAggregatesFilter | GolonganDarah | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumGolonganDarahNullableFilter
    _max?: NestedEnumGolonganDarahNullableFilter
  }

  export type NestedEnumAgamaFilter = {
    equals?: Agama
    in?: Enumerable<Agama>
    notIn?: Enumerable<Agama>
    not?: NestedEnumAgamaFilter | Agama
  }

  export type NestedEnumPendidikanFilter = {
    equals?: Pendidikan
    in?: Enumerable<Pendidikan>
    notIn?: Enumerable<Pendidikan>
    not?: NestedEnumPendidikanFilter | Pendidikan
  }

  export type NestedEnumHidupFilter = {
    equals?: Hidup
    in?: Enumerable<Hidup>
    notIn?: Enumerable<Hidup>
    not?: NestedEnumHidupFilter | Hidup
  }

  export type NestedEnumAgamaWithAggregatesFilter = {
    equals?: Agama
    in?: Enumerable<Agama>
    notIn?: Enumerable<Agama>
    not?: NestedEnumAgamaWithAggregatesFilter | Agama
    _count?: NestedIntFilter
    _min?: NestedEnumAgamaFilter
    _max?: NestedEnumAgamaFilter
  }

  export type NestedEnumPendidikanWithAggregatesFilter = {
    equals?: Pendidikan
    in?: Enumerable<Pendidikan>
    notIn?: Enumerable<Pendidikan>
    not?: NestedEnumPendidikanWithAggregatesFilter | Pendidikan
    _count?: NestedIntFilter
    _min?: NestedEnumPendidikanFilter
    _max?: NestedEnumPendidikanFilter
  }

  export type NestedEnumHidupWithAggregatesFilter = {
    equals?: Hidup
    in?: Enumerable<Hidup>
    notIn?: Enumerable<Hidup>
    not?: NestedEnumHidupWithAggregatesFilter | Hidup
    _count?: NestedIntFilter
    _min?: NestedEnumHidupFilter
    _max?: NestedEnumHidupFilter
  }

  export type NestedEnumTipeEventFilter = {
    equals?: TipeEvent
    in?: Enumerable<TipeEvent>
    notIn?: Enumerable<TipeEvent>
    not?: NestedEnumTipeEventFilter | TipeEvent
  }

  export type NestedEnumEventModelTypeFilter = {
    equals?: EventModelType
    in?: Enumerable<EventModelType>
    notIn?: Enumerable<EventModelType>
    not?: NestedEnumEventModelTypeFilter | EventModelType
  }

  export type NestedEnumTipeEventWithAggregatesFilter = {
    equals?: TipeEvent
    in?: Enumerable<TipeEvent>
    notIn?: Enumerable<TipeEvent>
    not?: NestedEnumTipeEventWithAggregatesFilter | TipeEvent
    _count?: NestedIntFilter
    _min?: NestedEnumTipeEventFilter
    _max?: NestedEnumTipeEventFilter
  }

  export type NestedEnumEventModelTypeWithAggregatesFilter = {
    equals?: EventModelType
    in?: Enumerable<EventModelType>
    notIn?: Enumerable<EventModelType>
    not?: NestedEnumEventModelTypeWithAggregatesFilter | EventModelType
    _count?: NestedIntFilter
    _min?: NestedEnumEventModelTypeFilter
    _max?: NestedEnumEventModelTypeFilter
  }

  export type NestedEnumTipeSesiFilter = {
    equals?: TipeSesi
    in?: Enumerable<TipeSesi>
    notIn?: Enumerable<TipeSesi>
    not?: NestedEnumTipeSesiFilter | TipeSesi
  }

  export type NestedEnumTipeSesiWithAggregatesFilter = {
    equals?: TipeSesi
    in?: Enumerable<TipeSesi>
    notIn?: Enumerable<TipeSesi>
    not?: NestedEnumTipeSesiWithAggregatesFilter | TipeSesi
    _count?: NestedIntFilter
    _min?: NestedEnumTipeSesiFilter
    _max?: NestedEnumTipeSesiFilter
  }

  export type GuruDetailsCreateWithoutUserInput = {
    guru: GuruCreateNestedOneWithoutGuruDetailsInput
    guruTahfidzDetail?: GuruTahfidzDetailsCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedCreateWithoutUserInput = {
    guruId: number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsCreateOrConnectWithoutUserInput = {
    where: GuruDetailsWhereUniqueInput
    create: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
  }

  export type MuridDetailsCreateWithoutUserInput = {
    murid: MuridCreateNestedOneWithoutMuridDetailsInput
    tahfidzDetails?: MuridTahfidzDetailsCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedCreateWithoutUserInput = {
    muridId: number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsCreateOrConnectWithoutUserInput = {
    where: MuridDetailsWhereUniqueInput
    create: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
  }

  export type ParentDetailsCreateWithoutUserInput = {
    parent: ParentCreateNestedOneWithoutParentDetailsInput
  }

  export type ParentDetailsUncheckedCreateWithoutUserInput = {
    parentId: number
  }

  export type ParentDetailsCreateOrConnectWithoutUserInput = {
    where: ParentDetailsWhereUniqueInput
    create: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
  }

  export type RolesCreateWithoutUserInput = {
    role: Role
  }

  export type RolesUncheckedCreateWithoutUserInput = {
    id?: number
    role: Role
  }

  export type RolesCreateOrConnectWithoutUserInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
  }

  export type RolesCreateManyUserInputEnvelope = {
    data: Enumerable<RolesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutActorInput = {
    type: TipeEvent
    target: EventModelType
    targetId: number
    time?: Date | string
  }

  export type EventUncheckedCreateWithoutActorInput = {
    id?: number
    type: TipeEvent
    target: EventModelType
    targetId: number
    time?: Date | string
  }

  export type EventCreateOrConnectWithoutActorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutActorInput, EventUncheckedCreateWithoutActorInput>
  }

  export type EventCreateManyActorInputEnvelope = {
    data: Enumerable<EventCreateManyActorInput>
    skipDuplicates?: boolean
  }

  export type GuruDetailsUpsertWithoutUserInput = {
    update: XOR<GuruDetailsUpdateWithoutUserInput, GuruDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<GuruDetailsCreateWithoutUserInput, GuruDetailsUncheckedCreateWithoutUserInput>
  }

  export type GuruDetailsUpdateWithoutUserInput = {
    guru?: GuruUpdateOneRequiredWithoutGuruDetailsInput
    guruTahfidzDetail?: GuruTahfidzDetailsUpdateOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedUpdateWithoutUserInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedUpdateOneWithoutGuruDetailsInput
  }

  export type MuridDetailsUpsertWithoutUserInput = {
    update: XOR<MuridDetailsUpdateWithoutUserInput, MuridDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<MuridDetailsCreateWithoutUserInput, MuridDetailsUncheckedCreateWithoutUserInput>
  }

  export type MuridDetailsUpdateWithoutUserInput = {
    murid?: MuridUpdateOneRequiredWithoutMuridDetailsInput
    tahfidzDetails?: MuridTahfidzDetailsUpdateOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedUpdateWithoutUserInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedUpdateOneWithoutMuridDetailsInput
  }

  export type ParentDetailsUpsertWithoutUserInput = {
    update: XOR<ParentDetailsUpdateWithoutUserInput, ParentDetailsUncheckedUpdateWithoutUserInput>
    create: XOR<ParentDetailsCreateWithoutUserInput, ParentDetailsUncheckedCreateWithoutUserInput>
  }

  export type ParentDetailsUpdateWithoutUserInput = {
    parent?: ParentUpdateOneRequiredWithoutParentDetailsInput
  }

  export type ParentDetailsUncheckedUpdateWithoutUserInput = {
    parentId?: IntFieldUpdateOperationsInput | number
  }

  export type RolesUpsertWithWhereUniqueWithoutUserInput = {
    where: RolesWhereUniqueInput
    update: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
    create: XOR<RolesCreateWithoutUserInput, RolesUncheckedCreateWithoutUserInput>
  }

  export type RolesUpdateWithWhereUniqueWithoutUserInput = {
    where: RolesWhereUniqueInput
    data: XOR<RolesUpdateWithoutUserInput, RolesUncheckedUpdateWithoutUserInput>
  }

  export type RolesUpdateManyWithWhereWithoutUserInput = {
    where: RolesScalarWhereInput
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type RolesScalarWhereInput = {
    AND?: Enumerable<RolesScalarWhereInput>
    OR?: Enumerable<RolesScalarWhereInput>
    NOT?: Enumerable<RolesScalarWhereInput>
    id?: IntFilter | number
    userId?: IntFilter | number
    role?: EnumRoleFilter | Role
  }

  export type EventUpsertWithWhereUniqueWithoutActorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutActorInput, EventUncheckedUpdateWithoutActorInput>
    create: XOR<EventCreateWithoutActorInput, EventUncheckedCreateWithoutActorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutActorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutActorInput, EventUncheckedUpdateWithoutActorInput>
  }

  export type EventUpdateManyWithWhereWithoutActorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutAuditLogsInput>
  }

  export type EventScalarWhereInput = {
    AND?: Enumerable<EventScalarWhereInput>
    OR?: Enumerable<EventScalarWhereInput>
    NOT?: Enumerable<EventScalarWhereInput>
    id?: IntFilter | number
    type?: EnumTipeEventFilter | TipeEvent
    target?: EnumEventModelTypeFilter | EventModelType
    targetId?: IntFilter | number
    userId?: IntFilter | number
    time?: DateTimeFilter | Date | string
  }

  export type UserCreateWithoutRolesInput = {
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsCreateNestedOneWithoutUserInput
    auditLogs?: EventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsUncheckedCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: EventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUpdateOneWithoutUserInput
    isParent?: ParentDetailsUpdateOneWithoutUserInput
    auditLogs?: EventUpdateManyWithoutActorInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUncheckedUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedUpdateOneWithoutUserInput
    isParent?: ParentDetailsUncheckedUpdateOneWithoutUserInput
    auditLogs?: EventUncheckedUpdateManyWithoutActorInput
  }

  export type GuruDetailsCreateWithoutGuruInput = {
    user: UserCreateNestedOneWithoutIsGuruInput
    guruTahfidzDetail?: GuruTahfidzDetailsCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedCreateWithoutGuruInput = {
    userId: number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedCreateNestedOneWithoutGuruDetailsInput
  }

  export type GuruDetailsCreateOrConnectWithoutGuruInput = {
    where: GuruDetailsWhereUniqueInput
    create: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
  }

  export type GuruDetailsUpsertWithoutGuruInput = {
    update: XOR<GuruDetailsUpdateWithoutGuruInput, GuruDetailsUncheckedUpdateWithoutGuruInput>
    create: XOR<GuruDetailsCreateWithoutGuruInput, GuruDetailsUncheckedCreateWithoutGuruInput>
  }

  export type GuruDetailsUpdateWithoutGuruInput = {
    user?: UserUpdateOneRequiredWithoutIsGuruInput
    guruTahfidzDetail?: GuruTahfidzDetailsUpdateOneWithoutGuruDetailsInput
  }

  export type GuruDetailsUncheckedUpdateWithoutGuruInput = {
    userId?: IntFieldUpdateOperationsInput | number
    guruTahfidzDetail?: GuruTahfidzDetailsUncheckedUpdateOneWithoutGuruDetailsInput
  }

  export type GuruCreateWithoutGuruDetailsInput = {
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    tanggalMasuk: Date | string
    profileUrl?: string | null
    deleted?: boolean
  }

  export type GuruUncheckedCreateWithoutGuruDetailsInput = {
    id?: number
    nig: string
    nigs: string
    kodeGuru: string
    nama: string
    email: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    tanggalMasuk: Date | string
    profileUrl?: string | null
    deleted?: boolean
  }

  export type GuruCreateOrConnectWithoutGuruDetailsInput = {
    where: GuruWhereUniqueInput
    create: XOR<GuruCreateWithoutGuruDetailsInput, GuruUncheckedCreateWithoutGuruDetailsInput>
  }

  export type UserCreateWithoutIsGuruInput = {
    username: string
    password: string
    deleted?: boolean
    isMurid?: MuridDetailsCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsCreateNestedOneWithoutUserInput
    roles?: RolesCreateNestedManyWithoutUserInput
    auditLogs?: EventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutIsGuruInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isMurid?: MuridDetailsUncheckedCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsUncheckedCreateNestedOneWithoutUserInput
    roles?: RolesUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: EventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutIsGuruInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIsGuruInput, UserUncheckedCreateWithoutIsGuruInput>
  }

  export type GuruTahfidzDetailsCreateWithoutGuruDetailsInput = {
    deleted?: boolean
    kelompokTahfidz?: HalaqohCreateNestedManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput = {
    deleted?: boolean
    kelompokTahfidz?: HalaqohUncheckedCreateNestedManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsCreateOrConnectWithoutGuruDetailsInput = {
    where: GuruTahfidzDetailsWhereUniqueInput
    create: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
  }

  export type GuruUpsertWithoutGuruDetailsInput = {
    update: XOR<GuruUpdateWithoutGuruDetailsInput, GuruUncheckedUpdateWithoutGuruDetailsInput>
    create: XOR<GuruCreateWithoutGuruDetailsInput, GuruUncheckedCreateWithoutGuruDetailsInput>
  }

  export type GuruUpdateWithoutGuruDetailsInput = {
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GuruUncheckedUpdateWithoutGuruDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nig?: StringFieldUpdateOperationsInput | string
    nigs?: StringFieldUpdateOperationsInput | string
    kodeGuru?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    tanggalMasuk?: DateTimeFieldUpdateOperationsInput | Date | string
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutIsGuruInput = {
    update: XOR<UserUpdateWithoutIsGuruInput, UserUncheckedUpdateWithoutIsGuruInput>
    create: XOR<UserCreateWithoutIsGuruInput, UserUncheckedCreateWithoutIsGuruInput>
  }

  export type UserUpdateWithoutIsGuruInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isMurid?: MuridDetailsUpdateOneWithoutUserInput
    isParent?: ParentDetailsUpdateOneWithoutUserInput
    roles?: RolesUpdateManyWithoutUserInput
    auditLogs?: EventUpdateManyWithoutActorInput
  }

  export type UserUncheckedUpdateWithoutIsGuruInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isMurid?: MuridDetailsUncheckedUpdateOneWithoutUserInput
    isParent?: ParentDetailsUncheckedUpdateOneWithoutUserInput
    roles?: RolesUncheckedUpdateManyWithoutUserInput
    auditLogs?: EventUncheckedUpdateManyWithoutActorInput
  }

  export type GuruTahfidzDetailsUpsertWithoutGuruDetailsInput = {
    update: XOR<GuruTahfidzDetailsUpdateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedUpdateWithoutGuruDetailsInput>
    create: XOR<GuruTahfidzDetailsCreateWithoutGuruDetailsInput, GuruTahfidzDetailsUncheckedCreateWithoutGuruDetailsInput>
  }

  export type GuruTahfidzDetailsUpdateWithoutGuruDetailsInput = {
    deleted?: BoolFieldUpdateOperationsInput | boolean
    kelompokTahfidz?: HalaqohUpdateManyWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedUpdateWithoutGuruDetailsInput = {
    deleted?: BoolFieldUpdateOperationsInput | boolean
    kelompokTahfidz?: HalaqohUncheckedUpdateManyWithoutGuruTahfidzDetailInput
  }

  export type GuruDetailsCreateWithoutGuruTahfidzDetailInput = {
    guru: GuruCreateNestedOneWithoutGuruDetailsInput
    user: UserCreateNestedOneWithoutIsGuruInput
  }

  export type GuruDetailsUncheckedCreateWithoutGuruTahfidzDetailInput = {
    guruId: number
    userId: number
  }

  export type GuruDetailsCreateOrConnectWithoutGuruTahfidzDetailInput = {
    where: GuruDetailsWhereUniqueInput
    create: XOR<GuruDetailsCreateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedCreateWithoutGuruTahfidzDetailInput>
  }

  export type HalaqohCreateWithoutGuruTahfidzDetailInput = {
    kode: string
    muridTahfidzDetail?: MuridTahfidzDetailsCreateNestedManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput = {
    id?: number
    kode: string
    muridTahfidzDetail?: MuridTahfidzDetailsUncheckedCreateNestedManyWithoutKelompokTahfidzInput
  }

  export type HalaqohCreateOrConnectWithoutGuruTahfidzDetailInput = {
    where: HalaqohWhereUniqueInput
    create: XOR<HalaqohCreateWithoutGuruTahfidzDetailInput, HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>
  }

  export type HalaqohCreateManyGuruTahfidzDetailInputEnvelope = {
    data: Enumerable<HalaqohCreateManyGuruTahfidzDetailInput>
    skipDuplicates?: boolean
  }

  export type GuruDetailsUpsertWithoutGuruTahfidzDetailInput = {
    update: XOR<GuruDetailsUpdateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedUpdateWithoutGuruTahfidzDetailInput>
    create: XOR<GuruDetailsCreateWithoutGuruTahfidzDetailInput, GuruDetailsUncheckedCreateWithoutGuruTahfidzDetailInput>
  }

  export type GuruDetailsUpdateWithoutGuruTahfidzDetailInput = {
    guru?: GuruUpdateOneRequiredWithoutGuruDetailsInput
    user?: UserUpdateOneRequiredWithoutIsGuruInput
  }

  export type GuruDetailsUncheckedUpdateWithoutGuruTahfidzDetailInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HalaqohUpsertWithWhereUniqueWithoutGuruTahfidzDetailInput = {
    where: HalaqohWhereUniqueInput
    update: XOR<HalaqohUpdateWithoutGuruTahfidzDetailInput, HalaqohUncheckedUpdateWithoutGuruTahfidzDetailInput>
    create: XOR<HalaqohCreateWithoutGuruTahfidzDetailInput, HalaqohUncheckedCreateWithoutGuruTahfidzDetailInput>
  }

  export type HalaqohUpdateWithWhereUniqueWithoutGuruTahfidzDetailInput = {
    where: HalaqohWhereUniqueInput
    data: XOR<HalaqohUpdateWithoutGuruTahfidzDetailInput, HalaqohUncheckedUpdateWithoutGuruTahfidzDetailInput>
  }

  export type HalaqohUpdateManyWithWhereWithoutGuruTahfidzDetailInput = {
    where: HalaqohScalarWhereInput
    data: XOR<HalaqohUpdateManyMutationInput, HalaqohUncheckedUpdateManyWithoutKelompokTahfidzInput>
  }

  export type HalaqohScalarWhereInput = {
    AND?: Enumerable<HalaqohScalarWhereInput>
    OR?: Enumerable<HalaqohScalarWhereInput>
    NOT?: Enumerable<HalaqohScalarWhereInput>
    id?: IntFilter | number
    kode?: StringFilter | string
    guruId?: IntFilter | number
  }

  export type MuridDetailsCreateWithoutMuridInput = {
    user: UserCreateNestedOneWithoutIsMuridInput
    tahfidzDetails?: MuridTahfidzDetailsCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedCreateWithoutMuridInput = {
    userId: number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedCreateNestedOneWithoutMuridDetailsInput
  }

  export type MuridDetailsCreateOrConnectWithoutMuridInput = {
    where: MuridDetailsWhereUniqueInput
    create: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
  }

  export type ParentCreateWithoutDaftarAnakInput = {
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
    parentDetails?: ParentDetailsCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutDaftarAnakInput = {
    id?: number
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
    parentDetails?: ParentDetailsUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutDaftarAnakInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutDaftarAnakInput, ParentUncheckedCreateWithoutDaftarAnakInput>
  }

  export type MuridDetailsUpsertWithoutMuridInput = {
    update: XOR<MuridDetailsUpdateWithoutMuridInput, MuridDetailsUncheckedUpdateWithoutMuridInput>
    create: XOR<MuridDetailsCreateWithoutMuridInput, MuridDetailsUncheckedCreateWithoutMuridInput>
  }

  export type MuridDetailsUpdateWithoutMuridInput = {
    user?: UserUpdateOneRequiredWithoutIsMuridInput
    tahfidzDetails?: MuridTahfidzDetailsUpdateOneWithoutMuridDetailsInput
  }

  export type MuridDetailsUncheckedUpdateWithoutMuridInput = {
    userId?: IntFieldUpdateOperationsInput | number
    tahfidzDetails?: MuridTahfidzDetailsUncheckedUpdateOneWithoutMuridDetailsInput
  }

  export type ParentUpsertWithWhereUniqueWithoutDaftarAnakInput = {
    where: ParentWhereUniqueInput
    update: XOR<ParentUpdateWithoutDaftarAnakInput, ParentUncheckedUpdateWithoutDaftarAnakInput>
    create: XOR<ParentCreateWithoutDaftarAnakInput, ParentUncheckedCreateWithoutDaftarAnakInput>
  }

  export type ParentUpdateWithWhereUniqueWithoutDaftarAnakInput = {
    where: ParentWhereUniqueInput
    data: XOR<ParentUpdateWithoutDaftarAnakInput, ParentUncheckedUpdateWithoutDaftarAnakInput>
  }

  export type ParentUpdateManyWithWhereWithoutDaftarAnakInput = {
    where: ParentScalarWhereInput
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyWithoutOrangTuaInput>
  }

  export type ParentScalarWhereInput = {
    AND?: Enumerable<ParentScalarWhereInput>
    OR?: Enumerable<ParentScalarWhereInput>
    NOT?: Enumerable<ParentScalarWhereInput>
    id?: IntFilter | number
    nip?: StringFilter | string
    nama?: StringFilter | string
    tempatLahir?: StringFilter | string
    tanggalLahir?: DateTimeFilter | Date | string
    jenisKelamin?: EnumJenisKelaminFilter | JenisKelamin
    agama?: EnumAgamaFilter | Agama
    pendidikanTerakhir?: EnumPendidikanFilter | Pendidikan
    penghasilanPerBulan?: IntFilter | number
    pekerjaan?: StringFilter | string
    nomorTelepon?: StringFilter | string
    statusHidup?: EnumHidupFilter | Hidup
    profileUrl?: StringNullableFilter | string | null
    deleted?: BoolFilter | boolean
  }

  export type MuridCreateWithoutMuridDetailsInput = {
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
    orangTua?: ParentCreateNestedManyWithoutDaftarAnakInput
  }

  export type MuridUncheckedCreateWithoutMuridDetailsInput = {
    id?: number
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
  }

  export type MuridCreateOrConnectWithoutMuridDetailsInput = {
    where: MuridWhereUniqueInput
    create: XOR<MuridCreateWithoutMuridDetailsInput, MuridUncheckedCreateWithoutMuridDetailsInput>
  }

  export type UserCreateWithoutIsMuridInput = {
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsCreateNestedOneWithoutUserInput
    roles?: RolesCreateNestedManyWithoutUserInput
    auditLogs?: EventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutIsMuridInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsUncheckedCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsUncheckedCreateNestedOneWithoutUserInput
    roles?: RolesUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: EventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutIsMuridInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIsMuridInput, UserUncheckedCreateWithoutIsMuridInput>
  }

  export type MuridTahfidzDetailsCreateWithoutMuridDetailsInput = {
    kelompokTahfidz: HalaqohCreateNestedOneWithoutMuridTahfidzDetailInput
    sesi?: SessionCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput = {
    kelompokTahfidzId: number
    sesi?: SessionUncheckedCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsCreateOrConnectWithoutMuridDetailsInput = {
    where: MuridTahfidzDetailsWhereUniqueInput
    create: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
  }

  export type MuridUpsertWithoutMuridDetailsInput = {
    update: XOR<MuridUpdateWithoutMuridDetailsInput, MuridUncheckedUpdateWithoutMuridDetailsInput>
    create: XOR<MuridCreateWithoutMuridDetailsInput, MuridUncheckedCreateWithoutMuridDetailsInput>
  }

  export type MuridUpdateWithoutMuridDetailsInput = {
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    orangTua?: ParentUpdateManyWithoutDaftarAnakInput
  }

  export type MuridUncheckedUpdateWithoutMuridDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutIsMuridInput = {
    update: XOR<UserUpdateWithoutIsMuridInput, UserUncheckedUpdateWithoutIsMuridInput>
    create: XOR<UserCreateWithoutIsMuridInput, UserUncheckedCreateWithoutIsMuridInput>
  }

  export type UserUpdateWithoutIsMuridInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUpdateOneWithoutUserInput
    isParent?: ParentDetailsUpdateOneWithoutUserInput
    roles?: RolesUpdateManyWithoutUserInput
    auditLogs?: EventUpdateManyWithoutActorInput
  }

  export type UserUncheckedUpdateWithoutIsMuridInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUncheckedUpdateOneWithoutUserInput
    isParent?: ParentDetailsUncheckedUpdateOneWithoutUserInput
    roles?: RolesUncheckedUpdateManyWithoutUserInput
    auditLogs?: EventUncheckedUpdateManyWithoutActorInput
  }

  export type MuridTahfidzDetailsUpsertWithoutMuridDetailsInput = {
    update: XOR<MuridTahfidzDetailsUpdateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedUpdateWithoutMuridDetailsInput>
    create: XOR<MuridTahfidzDetailsCreateWithoutMuridDetailsInput, MuridTahfidzDetailsUncheckedCreateWithoutMuridDetailsInput>
  }

  export type MuridTahfidzDetailsUpdateWithoutMuridDetailsInput = {
    kelompokTahfidz?: HalaqohUpdateOneRequiredWithoutMuridTahfidzDetailInput
    sesi?: SessionUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedUpdateWithoutMuridDetailsInput = {
    kelompokTahfidzId?: IntFieldUpdateOperationsInput | number
    sesi?: SessionUncheckedUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridDetailsCreateWithoutTahfidzDetailsInput = {
    murid: MuridCreateNestedOneWithoutMuridDetailsInput
    user: UserCreateNestedOneWithoutIsMuridInput
  }

  export type MuridDetailsUncheckedCreateWithoutTahfidzDetailsInput = {
    muridId: number
    userId: number
  }

  export type MuridDetailsCreateOrConnectWithoutTahfidzDetailsInput = {
    where: MuridDetailsWhereUniqueInput
    create: XOR<MuridDetailsCreateWithoutTahfidzDetailsInput, MuridDetailsUncheckedCreateWithoutTahfidzDetailsInput>
  }

  export type HalaqohCreateWithoutMuridTahfidzDetailInput = {
    kode: string
    guruTahfidzDetail: GuruTahfidzDetailsCreateNestedOneWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedCreateWithoutMuridTahfidzDetailInput = {
    id?: number
    kode: string
    guruId: number
  }

  export type HalaqohCreateOrConnectWithoutMuridTahfidzDetailInput = {
    where: HalaqohWhereUniqueInput
    create: XOR<HalaqohCreateWithoutMuridTahfidzDetailInput, HalaqohUncheckedCreateWithoutMuridTahfidzDetailInput>
  }

  export type SessionCreateWithoutMuridTahfidzDetailInput = {
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
  }

  export type SessionUncheckedCreateWithoutMuridTahfidzDetailInput = {
    id?: number
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
  }

  export type SessionCreateOrConnectWithoutMuridTahfidzDetailInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutMuridTahfidzDetailInput, SessionUncheckedCreateWithoutMuridTahfidzDetailInput>
  }

  export type SessionCreateManyMuridTahfidzDetailInputEnvelope = {
    data: Enumerable<SessionCreateManyMuridTahfidzDetailInput>
    skipDuplicates?: boolean
  }

  export type MuridDetailsUpsertWithoutTahfidzDetailsInput = {
    update: XOR<MuridDetailsUpdateWithoutTahfidzDetailsInput, MuridDetailsUncheckedUpdateWithoutTahfidzDetailsInput>
    create: XOR<MuridDetailsCreateWithoutTahfidzDetailsInput, MuridDetailsUncheckedCreateWithoutTahfidzDetailsInput>
  }

  export type MuridDetailsUpdateWithoutTahfidzDetailsInput = {
    murid?: MuridUpdateOneRequiredWithoutMuridDetailsInput
    user?: UserUpdateOneRequiredWithoutIsMuridInput
  }

  export type MuridDetailsUncheckedUpdateWithoutTahfidzDetailsInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type HalaqohUpsertWithoutMuridTahfidzDetailInput = {
    update: XOR<HalaqohUpdateWithoutMuridTahfidzDetailInput, HalaqohUncheckedUpdateWithoutMuridTahfidzDetailInput>
    create: XOR<HalaqohCreateWithoutMuridTahfidzDetailInput, HalaqohUncheckedCreateWithoutMuridTahfidzDetailInput>
  }

  export type HalaqohUpdateWithoutMuridTahfidzDetailInput = {
    kode?: StringFieldUpdateOperationsInput | string
    guruTahfidzDetail?: GuruTahfidzDetailsUpdateOneRequiredWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedUpdateWithoutMuridTahfidzDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    guruId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionUpsertWithWhereUniqueWithoutMuridTahfidzDetailInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutMuridTahfidzDetailInput, SessionUncheckedUpdateWithoutMuridTahfidzDetailInput>
    create: XOR<SessionCreateWithoutMuridTahfidzDetailInput, SessionUncheckedCreateWithoutMuridTahfidzDetailInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutMuridTahfidzDetailInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutMuridTahfidzDetailInput, SessionUncheckedUpdateWithoutMuridTahfidzDetailInput>
  }

  export type SessionUpdateManyWithWhereWithoutMuridTahfidzDetailInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutSesiInput>
  }

  export type SessionScalarWhereInput = {
    AND?: Enumerable<SessionScalarWhereInput>
    OR?: Enumerable<SessionScalarWhereInput>
    NOT?: Enumerable<SessionScalarWhereInput>
    id?: IntFilter | number
    type?: EnumTipeSesiFilter | TipeSesi
    waktu?: DateTimeFilter | Date | string
    juz?: IntFilter | number
    halaman?: IntFilter | number
    awalSetoran?: StringFilter | string
    akhirSetoran?: StringFilter | string
    nilaiTajwid?: IntFilter | number
    nilaiKelancaran?: IntFilter | number
    nilaiMakhroj?: IntFilter | number
    nilaiSifatHuruf?: IntFilter | number
    jamTahfidz?: StringFilter | string
    muridId?: IntFilter | number
  }

  export type ParentDetailsCreateWithoutParentInput = {
    user: UserCreateNestedOneWithoutIsParentInput
  }

  export type ParentDetailsUncheckedCreateWithoutParentInput = {
    userId: number
  }

  export type ParentDetailsCreateOrConnectWithoutParentInput = {
    where: ParentDetailsWhereUniqueInput
    create: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
  }

  export type MuridCreateWithoutOrangTuaInput = {
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
    muridDetails?: MuridDetailsCreateNestedOneWithoutMuridInput
  }

  export type MuridUncheckedCreateWithoutOrangTuaInput = {
    id?: number
    nis: string
    nism: string
    nisn?: string | null
    nama: string
    jenisKelamin: JenisKelamin
    tempatLahir: string
    tanggalLahir: Date | string
    anakKe: number
    jumlahSaudaraKandung: number
    jumlahSaudaraTiri: number
    jumlahSaudaraAngkat: number
    golonganDarah?: GolonganDarah | null
    profileUrl?: string | null
    deleted?: boolean
    muridDetails?: MuridDetailsUncheckedCreateNestedOneWithoutMuridInput
  }

  export type MuridCreateOrConnectWithoutOrangTuaInput = {
    where: MuridWhereUniqueInput
    create: XOR<MuridCreateWithoutOrangTuaInput, MuridUncheckedCreateWithoutOrangTuaInput>
  }

  export type ParentDetailsUpsertWithoutParentInput = {
    update: XOR<ParentDetailsUpdateWithoutParentInput, ParentDetailsUncheckedUpdateWithoutParentInput>
    create: XOR<ParentDetailsCreateWithoutParentInput, ParentDetailsUncheckedCreateWithoutParentInput>
  }

  export type ParentDetailsUpdateWithoutParentInput = {
    user?: UserUpdateOneRequiredWithoutIsParentInput
  }

  export type ParentDetailsUncheckedUpdateWithoutParentInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type MuridUpsertWithWhereUniqueWithoutOrangTuaInput = {
    where: MuridWhereUniqueInput
    update: XOR<MuridUpdateWithoutOrangTuaInput, MuridUncheckedUpdateWithoutOrangTuaInput>
    create: XOR<MuridCreateWithoutOrangTuaInput, MuridUncheckedCreateWithoutOrangTuaInput>
  }

  export type MuridUpdateWithWhereUniqueWithoutOrangTuaInput = {
    where: MuridWhereUniqueInput
    data: XOR<MuridUpdateWithoutOrangTuaInput, MuridUncheckedUpdateWithoutOrangTuaInput>
  }

  export type MuridUpdateManyWithWhereWithoutOrangTuaInput = {
    where: MuridScalarWhereInput
    data: XOR<MuridUpdateManyMutationInput, MuridUncheckedUpdateManyWithoutDaftarAnakInput>
  }

  export type MuridScalarWhereInput = {
    AND?: Enumerable<MuridScalarWhereInput>
    OR?: Enumerable<MuridScalarWhereInput>
    NOT?: Enumerable<MuridScalarWhereInput>
    id?: IntFilter | number
    nis?: StringFilter | string
    nism?: StringFilter | string
    nisn?: StringNullableFilter | string | null
    nama?: StringFilter | string
    jenisKelamin?: EnumJenisKelaminFilter | JenisKelamin
    tempatLahir?: StringFilter | string
    tanggalLahir?: DateTimeFilter | Date | string
    anakKe?: IntFilter | number
    jumlahSaudaraKandung?: IntFilter | number
    jumlahSaudaraTiri?: IntFilter | number
    jumlahSaudaraAngkat?: IntFilter | number
    golonganDarah?: EnumGolonganDarahNullableFilter | GolonganDarah | null
    profileUrl?: StringNullableFilter | string | null
    deleted?: BoolFilter | boolean
  }

  export type ParentCreateWithoutParentDetailsInput = {
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
    daftarAnak?: MuridCreateNestedManyWithoutOrangTuaInput
  }

  export type ParentUncheckedCreateWithoutParentDetailsInput = {
    id?: number
    nip: string
    nama: string
    tempatLahir: string
    tanggalLahir: Date | string
    jenisKelamin: JenisKelamin
    agama: Agama
    pendidikanTerakhir: Pendidikan
    penghasilanPerBulan: number
    pekerjaan: string
    nomorTelepon: string
    statusHidup: Hidup
    profileUrl?: string | null
    deleted?: boolean
  }

  export type ParentCreateOrConnectWithoutParentDetailsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutParentDetailsInput, ParentUncheckedCreateWithoutParentDetailsInput>
  }

  export type UserCreateWithoutIsParentInput = {
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsCreateNestedOneWithoutUserInput
    roles?: RolesCreateNestedManyWithoutUserInput
    auditLogs?: EventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutIsParentInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsUncheckedCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedCreateNestedOneWithoutUserInput
    roles?: RolesUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: EventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutIsParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIsParentInput, UserUncheckedCreateWithoutIsParentInput>
  }

  export type ParentUpsertWithoutParentDetailsInput = {
    update: XOR<ParentUpdateWithoutParentDetailsInput, ParentUncheckedUpdateWithoutParentDetailsInput>
    create: XOR<ParentCreateWithoutParentDetailsInput, ParentUncheckedCreateWithoutParentDetailsInput>
  }

  export type ParentUpdateWithoutParentDetailsInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    daftarAnak?: MuridUpdateManyWithoutOrangTuaInput
  }

  export type ParentUncheckedUpdateWithoutParentDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutIsParentInput = {
    update: XOR<UserUpdateWithoutIsParentInput, UserUncheckedUpdateWithoutIsParentInput>
    create: XOR<UserCreateWithoutIsParentInput, UserUncheckedCreateWithoutIsParentInput>
  }

  export type UserUpdateWithoutIsParentInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUpdateOneWithoutUserInput
    roles?: RolesUpdateManyWithoutUserInput
    auditLogs?: EventUpdateManyWithoutActorInput
  }

  export type UserUncheckedUpdateWithoutIsParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUncheckedUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedUpdateOneWithoutUserInput
    roles?: RolesUncheckedUpdateManyWithoutUserInput
    auditLogs?: EventUncheckedUpdateManyWithoutActorInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsCreateNestedOneWithoutUserInput
    roles?: RolesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    username: string
    password: string
    deleted?: boolean
    isGuru?: GuruDetailsUncheckedCreateNestedOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedCreateNestedOneWithoutUserInput
    isParent?: ParentDetailsUncheckedCreateNestedOneWithoutUserInput
    roles?: RolesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUpdateOneWithoutUserInput
    isParent?: ParentDetailsUpdateOneWithoutUserInput
    roles?: RolesUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    isGuru?: GuruDetailsUncheckedUpdateOneWithoutUserInput
    isMurid?: MuridDetailsUncheckedUpdateOneWithoutUserInput
    isParent?: ParentDetailsUncheckedUpdateOneWithoutUserInput
    roles?: RolesUncheckedUpdateManyWithoutUserInput
  }

  export type GuruTahfidzDetailsCreateWithoutKelompokTahfidzInput = {
    deleted?: boolean
    guruDetails: GuruDetailsCreateNestedOneWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput = {
    guruId: number
    deleted?: boolean
  }

  export type GuruTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput = {
    where: GuruTahfidzDetailsWhereUniqueInput
    create: XOR<GuruTahfidzDetailsCreateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
  }

  export type MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput = {
    muridDetails: MuridDetailsCreateNestedOneWithoutTahfidzDetailsInput
    sesi?: SessionCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput = {
    muridId: number
    sesi?: SessionUncheckedCreateNestedManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsCreateOrConnectWithoutKelompokTahfidzInput = {
    where: MuridTahfidzDetailsWhereUniqueInput
    create: XOR<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput, MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
  }

  export type MuridTahfidzDetailsCreateManyKelompokTahfidzInputEnvelope = {
    data: Enumerable<MuridTahfidzDetailsCreateManyKelompokTahfidzInput>
    skipDuplicates?: boolean
  }

  export type GuruTahfidzDetailsUpsertWithoutKelompokTahfidzInput = {
    update: XOR<GuruTahfidzDetailsUpdateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput>
    create: XOR<GuruTahfidzDetailsCreateWithoutKelompokTahfidzInput, GuruTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
  }

  export type GuruTahfidzDetailsUpdateWithoutKelompokTahfidzInput = {
    deleted?: BoolFieldUpdateOperationsInput | boolean
    guruDetails?: GuruDetailsUpdateOneRequiredWithoutGuruTahfidzDetailInput
  }

  export type GuruTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput = {
    guruId?: IntFieldUpdateOperationsInput | number
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MuridTahfidzDetailsUpsertWithWhereUniqueWithoutKelompokTahfidzInput = {
    where: MuridTahfidzDetailsWhereUniqueInput
    update: XOR<MuridTahfidzDetailsUpdateWithoutKelompokTahfidzInput, MuridTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput>
    create: XOR<MuridTahfidzDetailsCreateWithoutKelompokTahfidzInput, MuridTahfidzDetailsUncheckedCreateWithoutKelompokTahfidzInput>
  }

  export type MuridTahfidzDetailsUpdateWithWhereUniqueWithoutKelompokTahfidzInput = {
    where: MuridTahfidzDetailsWhereUniqueInput
    data: XOR<MuridTahfidzDetailsUpdateWithoutKelompokTahfidzInput, MuridTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput>
  }

  export type MuridTahfidzDetailsUpdateManyWithWhereWithoutKelompokTahfidzInput = {
    where: MuridTahfidzDetailsScalarWhereInput
    data: XOR<MuridTahfidzDetailsUpdateManyMutationInput, MuridTahfidzDetailsUncheckedUpdateManyWithoutMuridTahfidzDetailInput>
  }

  export type MuridTahfidzDetailsScalarWhereInput = {
    AND?: Enumerable<MuridTahfidzDetailsScalarWhereInput>
    OR?: Enumerable<MuridTahfidzDetailsScalarWhereInput>
    NOT?: Enumerable<MuridTahfidzDetailsScalarWhereInput>
    muridId?: IntFilter | number
    kelompokTahfidzId?: IntFilter | number
  }

  export type MuridTahfidzDetailsCreateWithoutSesiInput = {
    muridDetails: MuridDetailsCreateNestedOneWithoutTahfidzDetailsInput
    kelompokTahfidz: HalaqohCreateNestedOneWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedCreateWithoutSesiInput = {
    muridId: number
    kelompokTahfidzId: number
  }

  export type MuridTahfidzDetailsCreateOrConnectWithoutSesiInput = {
    where: MuridTahfidzDetailsWhereUniqueInput
    create: XOR<MuridTahfidzDetailsCreateWithoutSesiInput, MuridTahfidzDetailsUncheckedCreateWithoutSesiInput>
  }

  export type MuridTahfidzDetailsUpsertWithoutSesiInput = {
    update: XOR<MuridTahfidzDetailsUpdateWithoutSesiInput, MuridTahfidzDetailsUncheckedUpdateWithoutSesiInput>
    create: XOR<MuridTahfidzDetailsCreateWithoutSesiInput, MuridTahfidzDetailsUncheckedCreateWithoutSesiInput>
  }

  export type MuridTahfidzDetailsUpdateWithoutSesiInput = {
    muridDetails?: MuridDetailsUpdateOneRequiredWithoutTahfidzDetailsInput
    kelompokTahfidz?: HalaqohUpdateOneRequiredWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedUpdateWithoutSesiInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    kelompokTahfidzId?: IntFieldUpdateOperationsInput | number
  }

  export type RolesCreateManyUserInput = {
    id?: number
    role: Role
  }

  export type EventCreateManyActorInput = {
    id?: number
    type: TipeEvent
    target: EventModelType
    targetId: number
    time?: Date | string
  }

  export type RolesUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type RolesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type RolesUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type EventUpdateWithoutActorInput = {
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeEventFieldUpdateOperationsInput | TipeEvent
    target?: EnumEventModelTypeFieldUpdateOperationsInput | EventModelType
    targetId?: IntFieldUpdateOperationsInput | number
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HalaqohCreateManyGuruTahfidzDetailInput = {
    id?: number
    kode: string
  }

  export type HalaqohUpdateWithoutGuruTahfidzDetailInput = {
    kode?: StringFieldUpdateOperationsInput | string
    muridTahfidzDetail?: MuridTahfidzDetailsUpdateManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedUpdateWithoutGuruTahfidzDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
    muridTahfidzDetail?: MuridTahfidzDetailsUncheckedUpdateManyWithoutKelompokTahfidzInput
  }

  export type HalaqohUncheckedUpdateManyWithoutKelompokTahfidzInput = {
    id?: IntFieldUpdateOperationsInput | number
    kode?: StringFieldUpdateOperationsInput | string
  }

  export type ParentUpdateWithoutDaftarAnakInput = {
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    parentDetails?: ParentDetailsUpdateOneWithoutParentInput
  }

  export type ParentUncheckedUpdateWithoutDaftarAnakInput = {
    id?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    parentDetails?: ParentDetailsUncheckedUpdateOneWithoutParentInput
  }

  export type ParentUncheckedUpdateManyWithoutOrangTuaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    agama?: EnumAgamaFieldUpdateOperationsInput | Agama
    pendidikanTerakhir?: EnumPendidikanFieldUpdateOperationsInput | Pendidikan
    penghasilanPerBulan?: IntFieldUpdateOperationsInput | number
    pekerjaan?: StringFieldUpdateOperationsInput | string
    nomorTelepon?: StringFieldUpdateOperationsInput | string
    statusHidup?: EnumHidupFieldUpdateOperationsInput | Hidup
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionCreateManyMuridTahfidzDetailInput = {
    id?: number
    type: TipeSesi
    waktu?: Date | string
    juz: number
    halaman: number
    awalSetoran: string
    akhirSetoran: string
    nilaiTajwid: number
    nilaiKelancaran: number
    nilaiMakhroj: number
    nilaiSifatHuruf: number
    jamTahfidz: string
  }

  export type SessionUpdateWithoutMuridTahfidzDetailInput = {
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateWithoutMuridTahfidzDetailInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUncheckedUpdateManyWithoutSesiInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumTipeSesiFieldUpdateOperationsInput | TipeSesi
    waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    juz?: IntFieldUpdateOperationsInput | number
    halaman?: IntFieldUpdateOperationsInput | number
    awalSetoran?: StringFieldUpdateOperationsInput | string
    akhirSetoran?: StringFieldUpdateOperationsInput | string
    nilaiTajwid?: IntFieldUpdateOperationsInput | number
    nilaiKelancaran?: IntFieldUpdateOperationsInput | number
    nilaiMakhroj?: IntFieldUpdateOperationsInput | number
    nilaiSifatHuruf?: IntFieldUpdateOperationsInput | number
    jamTahfidz?: StringFieldUpdateOperationsInput | string
  }

  export type MuridUpdateWithoutOrangTuaInput = {
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    muridDetails?: MuridDetailsUpdateOneWithoutMuridInput
  }

  export type MuridUncheckedUpdateWithoutOrangTuaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    muridDetails?: MuridDetailsUncheckedUpdateOneWithoutMuridInput
  }

  export type MuridUncheckedUpdateManyWithoutDaftarAnakInput = {
    id?: IntFieldUpdateOperationsInput | number
    nis?: StringFieldUpdateOperationsInput | string
    nism?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    nama?: StringFieldUpdateOperationsInput | string
    jenisKelamin?: EnumJenisKelaminFieldUpdateOperationsInput | JenisKelamin
    tempatLahir?: StringFieldUpdateOperationsInput | string
    tanggalLahir?: DateTimeFieldUpdateOperationsInput | Date | string
    anakKe?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraKandung?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraTiri?: IntFieldUpdateOperationsInput | number
    jumlahSaudaraAngkat?: IntFieldUpdateOperationsInput | number
    golonganDarah?: NullableEnumGolonganDarahFieldUpdateOperationsInput | GolonganDarah | null
    profileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MuridTahfidzDetailsCreateManyKelompokTahfidzInput = {
    muridId: number
  }

  export type MuridTahfidzDetailsUpdateWithoutKelompokTahfidzInput = {
    muridDetails?: MuridDetailsUpdateOneRequiredWithoutTahfidzDetailsInput
    sesi?: SessionUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedUpdateWithoutKelompokTahfidzInput = {
    muridId?: IntFieldUpdateOperationsInput | number
    sesi?: SessionUncheckedUpdateManyWithoutMuridTahfidzDetailInput
  }

  export type MuridTahfidzDetailsUncheckedUpdateManyWithoutMuridTahfidzDetailInput = {
    muridId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}